import{_ as i,e as s,f as a,o as n}from"./app-LXiS_CCB.js";const t={};function l(r,e){return n(),s("div",null,e[0]||(e[0]=[a(`<h1 id="css" tabindex="-1"><a class="header-anchor" href="#css"><span>CSS</span></a></h1><p>本人是 CSS 超级苦手，甚至以前都只会写 nocss 页面。但是如果要给别人做东西用，nocss 肯定不太行。当今所有主流 GUI 框架中没一个打得过前端设计，我也想在前端领域玩玩，因此学习一点 CSS 是有必要的。</p><h2 id="预处理器" tabindex="-1"><a class="header-anchor" href="#预处理器"><span>预处理器</span></a></h2><p>css 本身不带逻辑，处理嵌套也麻烦。因此有各种各样的预处理器可以允许我们写更强大、更有意思的扩展语法，然后由它们在编译器改成标准 css。</p><ul><li>scss：sass 3.0 的别名，我觉得最泛用的。</li><li><a href="https://lesscss.org/" target="_blank" rel="noopener noreferrer">less</a>，朋友的公司在用</li></ul><p>上面两个预处理器都兼容原生 css。</p><h2 id="盒模型" tabindex="-1"><a class="header-anchor" href="#盒模型"><span>盒模型</span></a></h2><p>前端基础概念了。</p><ul><li>标准盒模型：<code>box-sizing: content-box</code>，content = size；border 和 padding 向外扩展，浏览器默认值。</li><li>IE 盒模型：<code>box-sizing: border-box</code>，content = size - border - padding，可以从外部统一大小，直观，方便编排。</li></ul><p>现在有一种实践是全局所有组件全部使用 IE 盒模型，我觉得还是比较有道理的，特别是前端初学者可以通过 IE 盒避开不少坑。</p><div style="position:relative;width:400px;"><!-- Margin Layer --><div style="background-color:#e8f4f8;padding:20px;text-align:center;border:2px dashed #a8d1dc;"><div style="position:absolute;top:0px;left:50%;transform:translateX(-50%);background-color:white;padding:2px 8px;border-radius:4px;font-size:14px;"> margin </div><!-- Border Layer --><div style="background-color:#ffb6b6;padding:20px;"><div style="position:absolute;top:20px;left:50%;transform:translateX(-50%);background-color:white;padding:2px 8px;border-radius:4px;font-size:14px;"> border </div><!-- Padding Layer --><div style="background-color:#e6ffe6;padding:20px;"><div style="position:absolute;top:40px;left:50%;transform:translateX(-50%);background-color:white;padding:2px 8px;border-radius:4px;font-size:14px;"> padding </div><!-- Content Layer --><div style="background-color:#fff2e6;padding:20px;text-align:center;">Content Area</div></div></div></div></div><h2 id="定位" tabindex="-1"><a class="header-anchor" href="#定位"><span>定位</span></a></h2><table><thead><tr><th>Position</th><th>描述</th></tr></thead><tbody><tr><td>static</td><td>默认值</td></tr><tr><td>relative</td><td>元素相对于其正常位置进行偏移。不影响文档流</td></tr><tr><td>absolute</td><td>元素相对于最近的已定位（非 static）祖先元素进行定位</td></tr><tr><td>fixed</td><td>元素相对于浏览器窗口进行定位</td></tr><tr><td>sticky</td><td>元素在跨越特定阈值前（屏幕内）表现为相对定位，之后表现为固定定位</td></tr></tbody></table><p>需要注意，使用 sticky 的同时必须指定 top、bottom、left、right 其中之一，并且在其任意级父元素上都不能出现 <code>overflow: auto</code> 和 <code>overflow: hidden</code>。</p><h2 id="自适应布局" tabindex="-1"><a class="header-anchor" href="#自适应布局"><span>自适应布局</span></a></h2><h3 id="flex" tabindex="-1"><a class="header-anchor" href="#flex"><span>flex</span></a></h3><p>flex 布局是自适应的绝佳实践，而且对于前端初学者来说，flex 也非常符合界面直觉。</p><p>关于版本：flex <a href="https://www.cnblogs.com/xiaohuochai/p/5323146.html" target="_blank" rel="noopener noreferrer">有多个版本</a>。2024 年了，不需要考虑 flex 兼容性，可以假定所有浏览器都支持最新版本 flex。</p><p>无脑 flex：</p><ol><li>想要让内部的玩意水平垂直居中，可以直接无脑 flex：<code>display: flex; align-items: center; justify-content: center;</code></li><li>想要让某个元素占满空间，可以给父元素设为 flex（不要设 align-items &amp; justify-content），然后该元素设为 <code>flex: 1</code>。</li></ol><p>flex 基础：</p><ol><li>主轴与交叉轴：主轴是元素排布的方向，交叉轴是与主轴垂直的方向。</li><li>basis, <a href="https://juejin.cn/post/6844904016439148551" target="_blank" rel="noopener noreferrer">grow and shrink</a><ul><li>basis 是每个元素的基础长度。默认为 0，此时使用元素 width （或 height）。</li><li>grow 是当所有元素填不满 flex 时，对于剩下的空间的瓜分策略。实际上就是按 grow 比例瓜分。</li><li>shrink 是当所有元素超出 flex 时，对所有元素的压缩策略。每个元素被压缩的空间也是按 shrink 比例压缩。</li></ul></li><li>对齐： <ul><li>主轴：<code>justify-content</code>。一般常用的有 <code>center</code>, <code>space-between</code>, <code>space-around</code>, <code>space-evenly</code></li><li>交叉轴：一旦使用了 flex，所有元素就会在交叉轴上被拉到最大（由默认值 <code>align-items: stretch;</code> 控制），非常直觉。</li></ul></li><li>超出自动换行：<code>flex-wrap: wrap;</code> 换行后又会引入行间对齐问题，使用 <code>align-content</code> 解决。</li></ol><p>flex 容易带来的问题：</p><ol><li>由于 flex 元素没有特定位置和大小，如果其子元素使用了百分比高度/宽度，生成的样式可能不是你所希望的。（是我的问题，不是 flex 的问题）</li><li>flex 并不保证元素不超过其边界，例如 shrink=0 的情况。</li><li>对于一个 <code>flex: 1</code> 项，我们通常不希望其内部的子元素将该项撑开，导致其比 flex 容器分配给它的空间更大。但是又无法直接设置 width，此时需要使用多种手段。<div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.flex-1-div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  flex: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  overflow: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">hidden</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  min-width: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* 或 min-height: 0; */</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.flex-1-div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  max-width: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">%</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  box-sizing: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">border-box</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="grid" tabindex="-1"><a class="header-anchor" href="#grid"><span>grid</span></a></h3><p>有时候，flex 并不能解决所有问题，特别是在有换行的情况下。例如我要做一个展示橱窗，有 9 个元素需要在当前区域 <code>justify-content: space-between;</code> 放置。其中五个元素在上面，四个元素被换行到下面。那么单纯用 flex 会导致上下不对齐，非常难受。</p><p>这时候就要用到 grid，grid 可以保证所有元素在自适应布局的同时还是对齐的。</p><h3 id="vh" tabindex="-1"><a class="header-anchor" href="#vh"><span>vh</span></a></h3><p>一般的响应式布局从获取屏幕宽高（100vw，100vh）开始。然而，100vh 在 safari，chrome 等 Android 浏览器上可能出现问题，因为 100vh 包括了被标题栏遮挡的区域。此时可以使用 svh。类似的新单位可以参考 <a href="https://learnbricksbuilder.com/demystifying-vh-dvh-svh-and-lvh-in-css/" target="_blank" rel="noopener noreferrer">Demystifying VH, DVH, SVH, and LVH in CSS</a>。</p><h2 id="框架" tabindex="-1"><a class="header-anchor" href="#框架"><span>框架</span></a></h2><p>虽说写原生 CSS 也不是不行，但是有框架为什么不用呢。</p><p>大多数框架都喜欢将 “写 css” 变为 “写 class”，免去了 html 和 css 之间切来切去的烦恼，用得熟练的话确实可以加快开发速度；特别是对基于 JSX 的前端框架非常有用。而写 vue 的话，css 框架对于初学者来说就是多了查文档的时间，如果文档烂的话还是挺烦人的。</p><ul><li><a href="https://unocss.dev/" target="_blank" rel="noopener noreferrer">UnoCSS</a>：新一代完全自定义化的 css 框架。</li><li><a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">tailwindcss</a>：一套预设的 class。目前广泛使用。</li><li>Bootstrap：老一辈预设的 class，目前算是被 tailwindcss 取代了吧(?)</li></ul><h3 id="tailwindcss" tabindex="-1"><a class="header-anchor" href="#tailwindcss"><span>TailwindCSS</span></a></h3><p>把 TailwindCSS 放在前面是因为即使直接上手其他 CSS 框架，也至少需要一点 TailwindCSS 基础。</p><ul><li><a href="https://tailwindcss.com/docs/customizing-colors" target="_blank" rel="noopener noreferrer">配色</a></li><li>建议使用 <a href="https://github.com/tailwindlabs/prettier-plugin-tailwindcss" target="_blank" rel="noopener noreferrer">prettier-plugin-tailwindcss</a> 对 tailwindcss class 进行排序。该插件也可以用于 UnoCSS。</li><li>如果能用 TailwindCSS 4.x 就不要用 3.x。4.x 的安装方式简单很多，不像 3.x 还要装 postcss 然后写一堆乱七八糟的东西。</li><li>TailwindCSS 只能写静态类名。所以不能写出 <code>bg-\${color}-500</code> 这种插值，否则编译的时候不会编出这个 style，样式就丢失了。</li><li>TailwindCSS 的距离单位，例如 <code>w-96</code> 等是<strong>离散</strong>的，并不是什么值都有样式，例如 <code>w-97</code> 就不行。<s>不服的话去用 UnoCSS（）</s></li><li>只有 <code>flex: 1</code> 可以写为 <code>flex-1</code>。其他 <code>flex: x</code> 要写为 <code>flex-[x]</code>。 <ul><li>同理，<code>max-width: 100vh</code> 要写成 <code>max-w-[100vh]</code>，并没有 <code>max-w-screen</code>。</li></ul></li></ul><p>进阶一些的技巧有：</p><ul><li>class alias：将一系列预设赋予一个别名，然后使用。在任意 css 中写入：<div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@layer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> utilities {</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  .btn-primary</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @apply bg-green-500 text-white py-2 px-4 rounded-lg;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>然后在组件里 import 该 css，将 <code>btn-primary</code> 当成新的 class 使用即可。 <code>@layer utilities</code> 指的是预设优先级，<code>utilities</code> &gt; <code>components</code> &gt; <code>base</code>。</li></ul><h4 id="插件" tabindex="-1"><a class="header-anchor" href="#插件"><span>插件</span></a></h4><ul><li><a href="https://github.com/reslear/tailwind-scrollbar-hide" target="_blank" rel="noopener noreferrer">tailwind-scrollbar-hide</a>：隐藏 scrollbar</li></ul><h3 id="unocss" tabindex="-1"><a class="header-anchor" href="#unocss"><span>UnoCSS</span></a></h3><p><a href="https://unocss.net/" target="_blank" rel="noopener noreferrer">UnoCSS</a> 是一个可自定义化程度非常高的 CSS 框架。可以设置任意类名 -&gt; 样式的映射和匹配规则，非常强大，并且可以无缝衔接 TailwindCSS，因此我现在已经转向 UnoCSS。</p><p>无缝衔接的条件是需要<a href="https://unocss.dev/presets/wind4" target="_blank" rel="noopener noreferrer">导入 TailwindCSS 的预设</a>。我可以在此预设之上添加一些个人的 rules。</p><p>不过这玩意也不是完全没有缺点，比如文档里好多 404 的链接没人维护，比如 VSCode 插件不如 TailwindCSS 的插件强大等。</p><ul><li>UnoCSS 的 alias 比 TailwindCSS 还更简单，只需要在 <code>uno.config.ts</code> 里加 <code>shortcuts: {...}</code> 即可。key 是别名，value 是类名。</li><li><a href="https://unocss.dev/config/preflights" target="_blank" rel="noopener noreferrer">preflights</a> 用于注入全局 CSS，例如<a href="https://github.com/lxl66566/super24points/blob/dee6e28a74b1b2ebe966446f3e52f4d91ff579e1/uno.config.ts#L13C4-L40" target="_blank" rel="noopener noreferrer">暗色滚动条</a>等。</li></ul><h2 id="external" tabindex="-1"><a class="header-anchor" href="#external"><span>external</span></a></h2><ol><li><a href="https://zh.learnlayout.com/" target="_blank" rel="noopener noreferrer">学习 CSS 布局</a></li><li><a href="https://leanrada.com/notes/css-only-lqip/" target="_blank" rel="noopener noreferrer">纯 CSS blur</a></li><li><a href="https://heibaimeng.com/post/218" target="_blank" rel="noopener noreferrer">Tailwind CSS 基础概念、配置、常见问题和使用笔记</a></li></ol>`,47)]))}const o=i(t,[["render",l],["__file","css.html.vue"]]),p=JSON.parse('{"path":"/coding/css.html","title":"CSS","lang":"zh-CN","frontmatter":{"date":"2024-12-13T00:00:00.000Z","icon":"brands fa-css","category":["编程"],"tag":["前端"],"description":"CSS 本人是 CSS 超级苦手，甚至以前都只会写 nocss 页面。但是如果要给别人做东西用，nocss 肯定不太行。当今所有主流 GUI 框架中没一个打得过前端设计，我也想在前端领域玩玩，因此学习一点 CSS 是有必要的。 预处理器 css 本身不带逻辑，处理嵌套也麻烦。因此有各种各样的预处理器可以允许我们写更强大、更有意思的扩展语法，然后由它们在...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CSS\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-13T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-01T02:19:20.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://absx.pages.dev/coding/css.html"}],["meta",{"property":"og:site_name","content":"绝对值_x 的博客"}],["meta",{"property":"og:title","content":"CSS"}],["meta",{"property":"og:description","content":"CSS 本人是 CSS 超级苦手，甚至以前都只会写 nocss 页面。但是如果要给别人做东西用，nocss 肯定不太行。当今所有主流 GUI 框架中没一个打得过前端设计，我也想在前端领域玩玩，因此学习一点 CSS 是有必要的。 预处理器 css 本身不带逻辑，处理嵌套也麻烦。因此有各种各样的预处理器可以允许我们写更强大、更有意思的扩展语法，然后由它们在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-01T02:19:20.000Z"}],["meta",{"property":"article:tag","content":"前端"}],["meta",{"property":"article:published_time","content":"2024-12-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-01T02:19:20.000Z"}]]},"git":{"createdTime":1734082658000,"updatedTime":1751336360000,"contributors":[{"name":"lxl66566","username":"lxl66566","email":"lxl66566@gmail.com","commits":13,"url":"https://github.com/lxl66566"}]},"readingTime":{"minutes":6.85,"words":2055},"filePathRelative":"coding/css.md","localizedDate":"2024年12月13日","excerpt":"\\n","autoDesc":true}');export{o as comp,p as data};
