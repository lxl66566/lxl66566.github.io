import{_ as i,e,f as a,o as t}from"./app-WliYw68u.js";const n={};function l(r,s){return t(),e("div",null,s[0]||(s[0]=[a(`<h1 id="solidjs" tabindex="-1"><a class="header-anchor" href="#solidjs"><span><a href="https://www.solidjs.com/" target="_blank" rel="noopener noreferrer">SolidJS</a></span></a></h1><p>SolidJS 是一个高性能轻量前端框架，其以 JSX 为核心，为 React 做了许多减法，少了很多难记的 Hooks，所以学起来非常快（不论有无 React 基础）。不过本文假设读者已经熟悉了 React 基础。</p><p>SolidJS 的哲学就是 small and simple。所以 React 高手用起来肯定没有那么方便舒服，很多地方需要自己手操低级逻辑。但是对新手来说是一件好事，SolidJS 的隐含条件少，不容易被框架坑。要说它的唯一缺点可能就是生态了，SolidJS 的包数量和可用性都要比 React 差上许多 (<a href="https://t.me/withabsolutex/2343" target="_blank" rel="noopener noreferrer">ref</a>)。</p><h2 id="props-与响应性" tabindex="-1"><a class="header-anchor" href="#props-与响应性"><span>props 与响应性</span></a></h2><p>在 React 中，有一个核心理念：<code>UI = f(state)</code>。这意味着整个组件的输出（UI）被看作是其当前 state 和 props 的一个函数。当 state 或 props 改变时，React 的做法不是去找到是哪个具体的值变了，而是重新执行整个组件函数，生成一个新的 Virtual DOM，然后通过比对新旧 VDOM，最后只把差异部分更新到真实的 DOM 上。</p><p>然而，<strong>SolidJS 的组件函数本身永远只运行一次</strong>。要让子组件随父组件的 signal 改变而重新渲染，需要传入 <code>Accessor&lt;T&gt;</code> 保持响应性。但是在任何一层子组件使用 <code>const { ... } = props</code> 解构，都会丢失 props 的响应性，导致子组件无法正确重新渲染。</p><p>要在保证响应性的同时解构 props，需要使用 SolidJS 提供的 <code>splitProps</code>。举个例子：</p><div class="language-tsx line-numbers-mode" data-highlighter="shiki" data-ext="tsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ButtonProps</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#50A14F;--shiki-dark:#E5C07B;"> JSX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ButtonHTMLAttributes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HTMLButtonElement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  children</span><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#E5C07B;"> JSX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Element</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  variant</span><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;primary&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;secondary&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;square&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;operator&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Button</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Component</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ButtonProps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // &#39;local&#39; 对象会包含这些 props，并且它们仍然是响应式的</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // &#39;rest&#39; 对象会包含所有剩余的 props</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">rest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> splitProps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;children&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;variant&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">  ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你在调试 SolidJS 项目时发现子组件没有正确渲染，请优先检查响应性。</p><h2 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks"><span>Hooks</span></a></h2><h3 id="createsignal" tabindex="-1"><a class="header-anchor" href="#createsignal"><span>createSignal</span></a></h3><p>就是 useState，最基本的响应式组成部分。</p><ul><li>每一次调用 <code>setState</code> 都会触发重新渲染。如果需要像 React 那样在值变化时才渲染，需要配合 <code>createMemo</code>。</li></ul><h3 id="createstore" tabindex="-1"><a class="header-anchor" href="#createstore"><span><a href="https://docs.solidjs.com/reference/store-utilities/create-store" target="_blank" rel="noopener noreferrer">createStore</a></span></a></h3><p>创建一个深层响应式对象，实现细粒度响应性（修改深层属性只会影响依赖了这个属性的节点）。一般用来存一些生命周期比较长、贯穿多个页面的东西，例如全局配置。</p><ul><li>由于该对象任何部分也都是响应式的，实际使用数据本身时要去掉这层 proxy，需要使用 <code>unwrap</code> 函数。</li></ul><h3 id="createcontext" tabindex="-1"><a class="header-anchor" href="#createcontext"><span><a href="https://docs.solidjs.com/reference/component-apis/create-context" target="_blank" rel="noopener noreferrer">createContext</a></span></a></h3><p>用来跨组件传输数据，不需要通过 props。只要在 provider 内都能拿到 context。</p><ul><li>一般可以配合 createStore 实现全局状态管理：createStore 负责响应式，createContext 负责让其他组件能拿到数据。 <ul><li>一般的 i18n，theme 都是这样实现的。</li></ul></li></ul><h3 id="createresource" tabindex="-1"><a class="header-anchor" href="#createresource"><span><a href="https://docs.solidjs.com/reference/basic-reactivity/create-resource" target="_blank" rel="noopener noreferrer">createResource</a></span></a></h3><p>一个 async 执行器的简单包装，可以跟踪执行状态。当然直接用 signal + 回调也是没有任何问题的。好像现在更多还是直接 signal，并没有太麻烦，还能减少学习成本。就是代码乱一些。</p><p>createResource 可以跟 Suspence 组件<a href="https://docs.solidjs.com/reference/components/suspense" target="_blank" rel="noopener noreferrer">配合使用</a>。其实就是包装了一下 <code>res.loading</code> 的判断而已。</p><h3 id="onmount" tabindex="-1"><a class="header-anchor" href="#onmount"><span>onMount</span></a></h3><p>因为每个组件函数只会执行一次，你可以直接将相关逻辑放在组件里；当然 SolidJS 也提供了 onMount hook 用于分离逻辑。</p><ul><li>其实还是有一些细微区别的，如果你要访问浏览器 API/DOM 信息，就得写在 onMount 里。</li></ul><h2 id="杂" tabindex="-1"><a class="header-anchor" href="#杂"><span>杂</span></a></h2><ul><li>SolidJS 的组件导出必须使用大写字母开头，否则 tsx 不会将其识别为组件。</li><li>SolidJS 的 createEffect、onCleanup 等必须在同步的组件构建阶段或父级 Effect 中执行，才能正确绑定。不允许在 async 函数中执行。</li></ul><h2 id="components" tabindex="-1"><a class="header-anchor" href="#components"><span>components</span></a></h2><p>SolidJS 也提供了一些内置组件，让写 Vue 的人倍感熟悉。</p><ul><li><code>&lt;Show when={...} fallback={...}&gt;&lt;/Show&gt;</code>，v-if + v-else</li><li><code>&lt;For each={...}&gt;&lt;/For&gt;</code>，v-for</li></ul><h2 id="配套设施" tabindex="-1"><a class="header-anchor" href="#配套设施"><span>配套设施</span></a></h2><p>SolidJS 虽然相对小众，但仍有着完善的生态系统。</p><ul><li>组件库：<a href="https://github.com/stefan-karger/solid-ui" target="_blank" rel="noopener noreferrer">SolidUI</a>，虽然我不太喜欢这个组件库的风格。</li><li>Router：<a href="https://github.com/solidjs/solid-router" target="_blank" rel="noopener noreferrer">solid-router</a></li><li>图标库：<a href="https://solid-icons.vercel.app/" target="_blank" rel="noopener noreferrer">Solid Icons</a></li><li>toast：<a href="https://github.com/ardeora/solid-toast" target="_blank" rel="noopener noreferrer">solid-toast</a></li><li>Markdown 渲染：<a href="https://github.com/andi23rosca/solid-markdown" target="_blank" rel="noopener noreferrer">solid-markdown</a></li></ul><p>这些基本都是事实标准，意味着如果你发现需要啥东西，不需要纠结用哪家的实现，用就完了。</p><p>但是很可惜，solid 用的人较少，导致很多库的 bug 都<a href="https://t.me/withabsolutex/2343" target="_blank" rel="noopener noreferrer">没人修</a>。</p>`,35)]))}const p=i(n,[["render",l],["__file","solidjs.html.vue"]]),h=JSON.parse('{"path":"/coding/solidjs.html","title":"SolidJS","lang":"zh-CN","frontmatter":{"date":"2025-01-04T00:00:00.000Z","icon":"arrow-up-right-dots","category":["编程"],"tag":["框架","前端"],"description":"SolidJS SolidJS 是一个高性能轻量前端框架，其以 JSX 为核心，为 React 做了许多减法，少了很多难记的 Hooks，所以学起来非常快（不论有无 React 基础）。不过本文假设读者已经熟悉了 React 基础。 SolidJS 的哲学就是 small and simple。所以 React 高手用起来肯定没有那么方便舒服，很多地方...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SolidJS\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-04T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T15:15:21.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://absx.pages.dev/coding/solidjs.html"}],["meta",{"property":"og:site_name","content":"绝对值_x 的博客"}],["meta",{"property":"og:title","content":"SolidJS"}],["meta",{"property":"og:description","content":"SolidJS SolidJS 是一个高性能轻量前端框架，其以 JSX 为核心，为 React 做了许多减法，少了很多难记的 Hooks，所以学起来非常快（不论有无 React 基础）。不过本文假设读者已经熟悉了 React 基础。 SolidJS 的哲学就是 small and simple。所以 React 高手用起来肯定没有那么方便舒服，很多地方..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T15:15:21.000Z"}],["meta",{"property":"article:tag","content":"前端"}],["meta",{"property":"article:tag","content":"框架"}],["meta",{"property":"article:published_time","content":"2025-01-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T15:15:21.000Z"}]]},"git":{"createdTime":1736014766000,"updatedTime":1767798921000,"contributors":[{"name":"lxl66566","username":"lxl66566","email":"lxl66566@gmail.com","commits":10,"url":"https://github.com/lxl66566"}]},"readingTime":{"minutes":3.86,"words":1158},"filePathRelative":"coding/solidjs.md","localizedDate":"2025年1月4日","excerpt":"\\n","autoDesc":true}');export{p as comp,h as data};
