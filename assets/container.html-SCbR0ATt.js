import{_ as r,e as k,f as l,k as d,i as o,j as e,r as p,o as c,g as i,h as s}from"./app-DsHY3XAV.js";const g={};function A(y,a){const h=p("Tabs");return c(),k("div",null,[a[4]||(a[4]=l(`<h1 id="容器" tabindex="-1"><a class="header-anchor" href="#容器"><span>容器</span></a></h1><p>其实我一直不喜欢容器，我认为处理复杂依赖是包管理器的职责，推给 container 是比较粗暴浪费空间的做法。然而比起虚拟机，容器的开销确实小多了，还是有一定价值的<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>。</p><h2 id="选择" tabindex="-1"><a class="header-anchor" href="#选择"><span>选择</span></a></h2><p>最流行的容器工具应该就是 docker 了吧，然而因为几次负面消息<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup><sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>让我对其没有任何好感。</p><p>我也尝试在 wsl2 上部署了一下 docker，然而由于没有 systemctl 而无法启动其守护进程。<a href="https://github.com/gdraheim/docker-systemctl-replacement" target="_blank" rel="noopener noreferrer">docker-systemctl-replacement</a> 不可用，需要 nohup 启动 <code>dockerd</code>。我的 wsl2 只有纯命令行，折腾许久，浪费了许多时间。</p><p>于是我转向了 <a href="https://docs.podman.io" target="_blank" rel="noopener noreferrer">podman</a>，这是一个 <strong>daemonless, open source</strong>（开源的、无守护进程的）容器工具，解决了我对 docker 的偏见。并且其兼容性也不错：<em>Most users can simply alias Docker to Podman (alias docker=podman) without any problems.</em>。不过 podman 也有缺点，例如<a href="#%E5%85%B3%E4%BA%8E%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8">开机自启</a>要麻烦一些。可以前往 <a href="#external">external 1.</a> 查看详细信息。</p><p>再说说平台兼容性：</p><ul><li>Linux 随便选啥都行，而且跑容器是没有性能损失的。</li><li>Windows 上如果懒人就使用 Docker Desktop 一键配置（也是基于 WSL 的运行方式），想折腾就开 WSL，在 WSL 里装个发行版然后当 linux 用。</li><li>MacOS 有 <a href="https://github.com/apple/container" target="_blank" rel="noopener noreferrer">apple/container</a> 用，当然也可以装 Docker Desktop，不过有原生的话可能没啥必要。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>本篇中 docker 和 podman 命令是混用的。</p></div><h2 id="工具" tabindex="-1"><a class="header-anchor" href="#工具"><span>工具</span></a></h2><ul><li><a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener noreferrer">lazydocker</a>：lazygit 的同作者做的 docker TUI，不再需要背 docker 指令。 <ul><li>实际上 docker 的 cli 确实很傻逼，很多地方依赖 hash。</li></ul></li><li><a href="https://github.com/donknap/dpanel" target="_blank" rel="noopener noreferrer">dpanel</a>：更高级的 docker 管理 GUI。</li></ul><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><p>看看<a href="https://github.com/containers/podman/blob/main/docs/tutorials/podman_tutorial_cn.md" target="_blank" rel="noopener noreferrer">tutorial</a>。</p><p><strong>容器</strong>和<strong>镜像</strong>是两个概念，可以类比为系统和系统盘。</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ps</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                 # 查看运行状态</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ps</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -a</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                              # 查看所有容器状态</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ...</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                         # -d 表示后台运行</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rm</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nam</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;                          </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 删除容器</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> logs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nam</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;                        </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看输出 (stdout + stderr)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> logs</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nam</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;                     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 持续查看输出 (stdout + stderr)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pull</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">repositor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ta</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">g&gt;            </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 拉取镜像到本地</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> images</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                             # 查看镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">image</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> I</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">D&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">repositor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ta</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">g&gt;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 重命名镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> stop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> $(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ps</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -aq</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)              </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 停止所有容器</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rm</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> $(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ps</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -aq</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)                </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 删除所有容器</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rmi</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> $(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> images</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)            </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 删除所有镜像</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="调试" tabindex="-1"><a class="header-anchor" href="#调试"><span>调试</span></a></h3><ul><li>我可以从一个 image 新建一个容器，忽略 CMD 而直接进 <code>/bin/bash</code> 进行 image 调试：<code>docker run -it &lt;image&gt; /bin/bash</code></li><li>我也可以进入一个正在运行的容器的主进程：<code>docker attach &lt;container&gt;</code></li><li>但是我不能对一个运行中或已退出的容器<strong>新开一个 bash 进程</strong>进行调试，这是非常致命的。只能用 <code>docker exec</code>。</li></ul><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -it</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --entrypoint</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /bin/bash</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">imag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 从 image 创建容器并进入（作为调试用）</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> build</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> .</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                    # 构建容器镜像（需要先下载 docker-buildx，否则会吃一个 deprecated。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                                  # 下载完后，docker build 相当于 docker buildx build 的 alias）</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> system</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> prune</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                               # 清理所有缓存、非运行中的镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> builder</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> prune</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -a</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                           # 清理构建缓存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="代理" tabindex="-1"><a class="header-anchor" href="#代理"><span>代理</span></a></h2><p><a href="https://wiki.archlinuxcn.org/wiki/Docker#HTTP%E4%BB%A3%E7%90%86" target="_blank" rel="noopener noreferrer">src</a></p><p>简言之：守护进程和 docker 都需要配置，<code>/etc/docker/daemon.json</code> 和 <code>~/.docker/config.json</code> 都需要写入代理内容。</p><p>而且注意，容器内部无法直接通过 localhost，127.0.0.1 访问宿主机代理端口，解法在<a href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%9C%8D%E5%8A%A1">容器中访问宿主机服务</a>。</p><p>如果你的容器有指定虚拟子网，记得将互相的容器名加入 <code>NO_PROXY</code>，否则可能出现通信错误。</p><h2 id="dockerhub-mirror" tabindex="-1"><a class="header-anchor" href="#dockerhub-mirror"><span>dockerhub mirror</span></a></h2><p>在 2024 年，中国大规模下架了 docker 镜像。所以现在想要使用 docker 仓库会有一些麻烦。<a href="https://taogenjia.com/2024/08/19/Using-docker-in-China-2024/" target="_blank" rel="noopener noreferrer">Using docker in China 2024</a> 这篇文章介绍了一些方法，我尝试了 cloudflare 反代。不过反代的后果也是 UNAUTHORIZED。</p><p>然后还踩了<a href="#%E6%97%A0%E6%B3%95%E5%BA%94%E7%94%A8%E9%95%9C%E5%83%8F">应用镜像的坑</a>。</p><h2 id="容器中访问宿主机服务" tabindex="-1"><a class="header-anchor" href="#容器中访问宿主机服务"><span>容器中访问宿主机服务</span></a></h2><p>最佳解法：使用宿主机的局域网 ip，并且关掉防火墙。</p><p>其他办法都挺麻烦的，例如 <code>host.docker.internal</code> 只在 Docker Desktop 上能用，而 linux <code>ip addr show docker0</code> 的 <code>172.17.0.1</code> 试过了用不了。</p><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile"><span>Dockerfile</span></a></h2><p>如果你需要制作一个镜像，那么本质上就是写一个 Dockerfile 用来描述镜像。</p>`,31)),d(" prettier-ignore "),a[5]||(a[5]=l(`<table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td>ENV</td><td>设置环境变量。对所有之后的指令生效，可以多次覆盖。</td></tr><tr><td>COPY</td><td>将外部文件复制到容器内。了解更多请阅读<a href="#%E5%9D%91">坑</a>。</td></tr></tbody></table><p>每个 <code>ADD</code>，<code>COPY</code>，<code>RUN</code> 指令会为 image 创建一个只读 UnionFS layer。layer 是用于缓存的，当修改了 Dockerfile 的某一行后，系统只会构建此行和所有之后的指令，之前的 layer 可以被跳过构建。也正是因为 layer 的存在，尽可能不要写紧邻的 <code>RUN</code> 语句，如果每个 command 都分配一个 <code>RUN</code> 语句会导致 layer 过多，影响存储和性能。</p><h3 id="坑" tabindex="-1"><a class="header-anchor" href="#坑"><span>坑</span></a></h3><p>Dockerfile 的坑实在是太多了，真是他妈的屎一样的设计。</p><ul><li>类似 .gitignore，Docker 也有 .dockerignore 用于在 COPY 时忽略文件/文件夹。但是它和 .gitignore 不一致的地方很多： <ol><li>.gitignore 可以放在任意子目录下，.dockerignore 只能放在你的 build 目录下，否则不生效。</li><li>.gitignore 里的内容可以匹配任意层子目录下的文件名，而 .dockerfile 只能匹配 build 目录下的路径。相当于 .gitignore 里的 <code>xxx</code> 在 .dockerfile 里都要写成 <code>**/xxx</code> 或者绝对路径 <code>/aaa/bbb/xxx</code>。</li></ol></li><li><code>COPY a b</code> 命令指的是将 <code>a</code> 目录<strong>下的所有文件</strong> copy 到 <code>b</code> 目录里，而不是将 <code>a</code> 目录本身 copy 到 <code>b</code> 目录里。这跟 <code>cp -r</code> 的表现又不一样。</li></ul><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络"><span>网络</span></a></h2><p>docker 网络有四种模式，Host（和宿主共用网卡 IP 端口）, Container（和其他容器共用网卡 IP 端口）, None, Bridge（虚拟子网）。</p><p>一般容器间通信可以用 Container 也可以用 Bridge，Container 不用额外配置，Bridge 则更灵活。</p><p>Bridge 组网大致如下：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> network</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                           # 先创建虚拟子网</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 通过 --network (--net) 指定虚拟子网</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> AAA</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 8000:8000</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --network</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">imag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;         </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 假设这是一个提供服务的容器</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -it</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> BBB</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 8000:8000</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --network</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">imag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">sh</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     # 假设这是一个访问服务的容器</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">NO_PROXY</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">AAA</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> curl</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -v</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> http://AAA:8000</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                # 访问 AAA 的服务。如果你设置了代理，要保证虚拟子网内的请求不走代理。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，Bridge 需要修改容器内程序的源码或 env 以适配新的 base url，还是有一些麻烦的。好处是可以加新的容器到子网，或者随便更换服务提供容器都行。</p><h2 id="为离线机器下载镜像" tabindex="-1"><a class="header-anchor" href="#为离线机器下载镜像"><span>为离线机器下载镜像</span></a></h2><p>假设我有无法联网的内网服务器，我需要使用其跑镜像。</p>`,13)),o(h,{id:"221",data:[{id:"使用 docker 导出"},{id:"使用脚本下载（无法使用）"}]},{title0:e(({value:t,isActive:n})=>a[0]||(a[0]=[s("使用 docker 导出")])),title1:e(({value:t,isActive:n})=>a[1]||(a[1]=[s("使用脚本下载（无法使用）")])),tab0:e(({value:t,isActive:n})=>a[2]||(a[2]=[i("p",null,"如果你的电脑上安装了 docker，你应该优先选择这个方法。",-1),i("ol",null,[i("li",null,[s("使用 docker pull 拉取镜像。注意你的"),i("strong",null,"目标架构"),s("需要与服务器的架构相同。"),i("div",{class:"language-sh line-numbers-mode","data-highlighter":"shiki","data-ext":"sh",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"docker"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," pull"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," --platform"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," linux/arm64"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," hectorqin/reader:openj9-latest")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"})])])]),i("li",null,[s("使用 "),i("code",null,"docker save"),s(" 导出指定镜像。如果你有多个镜像，并且 docker 内所有镜像都需要导出，你可以用脚本批量导出："),i("div",{class:"language-sh line-numbers-mode","data-highlighter":"shiki","data-ext":"sh",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"#!/bin/bash")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"output_dir"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'"docker_images"')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"mkdir"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," -p"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "'),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$output_dir"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'"')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"for"),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}}," image"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," in"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," $("),i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"docker"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," images"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," --format"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "{{.Repository}}:{{.Tag}}"'),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"); "),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"do")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#0184BC","--shiki-dark":"#56B6C2"}},"    echo"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "Saving '),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$image"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'..."')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"    file_name"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"$("),i("span",{style:{"--shiki-light":"#0184BC","--shiki-dark":"#56B6C2"}},"echo"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "'),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$image"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'"'),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," | "),i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"sed"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," 's/[\\/:]/_/g'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},")"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},".tar")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"    docker"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," save"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," -o"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "'),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$output_dir"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},"/"),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$file_name"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'"'),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "'),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$image"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'"')]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"done")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#0184BC","--shiki-dark":"#56B6C2"}},"echo"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "All images saved to '),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$output_dir"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'/"')])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])])]),i("li",null,[s("通过 rsync 或者其他方法将所有 "),i("code",null,".tar"),s(" 传输到目标机器上")]),i("li",null,[s("使用 "),i("code",null,"docker load"),s(" 加载所有镜像。")])],-1)])),tab1:e(({value:t,isActive:n})=>a[3]||(a[3]=[i("p",null,[i("a",{href:"https://github.com/NotGlop/docker-drag",target:"_blank",rel:"noopener noreferrer"},"docker-drag"),s(" 用不了，别看了。我用的算是官方的 moby 脚本吧。")],-1),i("div",{class:"language-sh line-numbers-mode","data-highlighter":"shiki","data-ext":"sh",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"wget"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," https://raw.githubusercontent.com/moby/moby/master/contrib/download-frozen-image-v2.sh")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"chmod"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," +x"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," download-frozen-image-v2.sh")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"bash"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," download-frozen-image-v2.sh"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," reader"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," hectorqin/reader:openj9-latest")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"tar"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," -cvaf"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," reader.tar"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," reader")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 这样就把镜像下载并打成了 tar 包。")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1),i("p",null,"不过这个脚本在 20241204 时还有 bug，就是必须指定 image 的 tag，否则下载链接会 404。",-1),i("p",null,"好不容易下载完了，结果打出的 tar 还不能直接被 docker load 加载，非常神奇。我不知道怎么办了。",-1)])),_:1}),a[6]||(a[6]=l(`<h2 id="docker-compose" tabindex="-1"><a class="header-anchor" href="#docker-compose"><span>docker-compose</span></a></h2><p>docker-compose 是 docker 的上一层抽象，一言：<strong>一个 yaml 文件，指明了多个容器的参数</strong>。实际上使用一个 bash 脚本也能做到 docker-compose 做的事。</p><h2 id="关于开机自启动" tabindex="-1"><a class="header-anchor" href="#关于开机自启动"><span>关于开机自启动</span></a></h2><p>docker 容器非常方便，用 <code>--restart always</code>（总是自动重启）或 <code>--restart unless-stopped</code>（除非手动停止，否则总是自动重启）启动容器就行。</p><p>但是 podman 是 rootless 的，没有一个守护进程去叫醒容器，<code>--restart</code> 参数对其无效。使用 systemd 用户服务的话，按照网上教程 <code>podman generate systemd</code> 又会发现 command deprecated，而且这样无法启动 podman-compose 生成的 pod。</p><p>然后我又<a href="https://t.me/withabsolutex/2199" target="_blank" rel="noopener noreferrer">折腾了一段时间</a>。遇到了太多无语的事情。</p><p>最后我的解决方法：回归本源，每次开机时运行 <code>user-startup add &#39;/usr/bin/podman pod start pod_root&#39;</code> 来启动 pod。至于开机自启动命令，可以用我的 <a href="https://github.com/lxl66566/user-startup-rs" target="_blank" rel="noopener noreferrer">user-startup</a>，一行搞定。</p><h2 id="遇到的问题" tabindex="-1"><a class="header-anchor" href="#遇到的问题"><span>遇到的问题</span></a></h2><h3 id="无法应用镜像" tabindex="-1"><a class="header-anchor" href="#无法应用镜像"><span>无法应用镜像</span></a></h3><ul><li>网上教程修改镜像都是 <code>/etc/docker/daemon.json</code>，改完重启 docker。但是我重启后并无法应用镜像。 <ul><li>OS：iStoreOS</li></ul></li></ul><p>解法：<code>ps | grep dockerd</code>，可以看到应用的 config 是 <code>--config-file=/tmp/dockerd/daemon.json</code>，根本就不是 <code>/etc/docker/daemon.json</code>。</p><p>继续看 <code>/etc/init.d/dockerd</code>，可以发现其 config 是写在奇怪的地方，并且格式也是自定义格式。（<a href="https://t.me/withabsolutex/2119" target="_blank" rel="noopener noreferrer">被我喷了</a>）</p><h3 id="podman-指定-registry" tabindex="-1"><a class="header-anchor" href="#podman-指定-registry"><span>podman 指定 registry</span></a></h3><ul><li>podman 拉取镜像时可能不支持短名称，需要在名称前加 <code>docker.io/</code> 前缀，或者如 external 1. 所述：Open your <code>$HOME/.config/containers/registries.conf</code> file and paste the following contents: <code>unqualified-search-registries=[&quot;docker.io&quot;]</code></li></ul><h3 id="var-run-docker-sock-connect-permission-denied" tabindex="-1"><a class="header-anchor" href="#var-run-docker-sock-connect-permission-denied"><span>/var/run/docker.sock: connect: permission denied</span></a></h3><p>这个也是常见问题了，守护进程运行在 root 下，普通用户无法访问。解法(<a href="https://stackoverflow.com/questions/48568172" target="_blank" rel="noopener noreferrer">ref</a>)：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> usermod</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -aG</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> docker</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $USER</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后重新登录。</p><h3 id="安装问题" tabindex="-1"><a class="header-anchor" href="#安装问题"><span>安装问题</span></a></h3><p>正常的 Linux 发行版的包管理器安装都不会出现问题。不过 WSL 就折磨了。我用 ArchWSL，结果 docker 没有守护进程，podman 爆 subuid 错误。</p><h4 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>docker</span></a></h4><p>ArchWSL 上没有 systemd 用，所以自然也不会自行启动 dockerd 守护进程。因此我必须要在另一个 console 上手动运行 <code>sudo dockerd</code> 才能正常使用 docker。</p><h4 id="podman" tabindex="-1"><a class="header-anchor" href="#podman"><span>podman</span></a></h4><p>在 ArchWSL 上 podman 找不到 <code>/etc/subuid</code>，报错。subuid 和 subgid 是用于 User Namespaces 的一部分，主要用于容器化软件，以创建特权分离的容器。</p><p>运行指令：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> usermod</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --add-subuids</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 100000-165535</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">use</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">r&gt;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> usermod</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --add-subgids</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 100000-165535</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">use</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">r&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>解决。</p><h2 id="external" tabindex="-1"><a class="header-anchor" href="#external"><span>external</span></a></h2><ol><li><a href="https://betterstack.com/community/guides/scaling-docker/podman-vs-docker/" target="_blank" rel="noopener noreferrer">Exploring Podman: A More Secure Docker Alternative</a></li><li><a href="https://note.aya1.de/#/22-podman" target="_blank" rel="noopener noreferrer">podman 踩坑记录 - Aya</a> | <a href="https://github.com/Brx86/brx86.github.io/blob/5b03fc42683587be98bf6c72685a69d6d86b5c25/22-podman.md" target="_blank" rel="noopener noreferrer">source code</a></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>抽象层次与价值取向绑定。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>Docker 向所有 Docker Hub 用户发去邮件，如果他们是以组织的名义创建账号，那么他们的账号将被删除，所有镜像也将一并删除，除非他们升级到一个付费的团队方案——其年费为 420 美元。<a href="https://www.solidot.org/story?sid=74406" target="_blank" rel="noopener noreferrer">src: solidot</a> <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>Docker 公司将限制其 Docker Desktop 工具仅供个人或小企业免费使用，大企业将需要<a href="https://www.theregister.com/2021/08/31/docker_desktop_no_longer_free/" target="_blank" rel="noopener noreferrer">付费订阅</a>。该公司要求员工人数在 250 人以上或年收入超过一千万美元的企业如果需要使用 Docker Desktop 那么就必须付费订阅。<a href="https://www.solidot.org/story?sid=68775" target="_blank" rel="noopener noreferrer">src: solidot</a> <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li></ol></section>`,31))])}const m=r(g,[["render",A],["__file","container.html.vue"]]),u=JSON.parse('{"path":"/coding/container.html","title":"容器","lang":"zh-CN","frontmatter":{"icon":"box","date":"2023-11-12T00:00:00.000Z","category":["编程","教程"],"tag":["工具"],"description":"容器 其实我一直不喜欢容器，我认为处理复杂依赖是包管理器的职责，推给 container 是比较粗暴浪费空间的做法。然而比起虚拟机，容器的开销确实小多了，还是有一定价值的[1]。 选择 最流行的容器工具应该就是 docker 了吧，然而因为几次负面消息[2][3]让我对其没有任何好感。 我也尝试在 wsl2 上部署了一下 docker，然而由于没有 s...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"容器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-12T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-08T15:04:03.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://absx.pages.dev/coding/container.html"}],["meta",{"property":"og:site_name","content":"绝对值_x 的博客"}],["meta",{"property":"og:title","content":"容器"}],["meta",{"property":"og:description","content":"容器 其实我一直不喜欢容器，我认为处理复杂依赖是包管理器的职责，推给 container 是比较粗暴浪费空间的做法。然而比起虚拟机，容器的开销确实小多了，还是有一定价值的[1]。 选择 最流行的容器工具应该就是 docker 了吧，然而因为几次负面消息[2][3]让我对其没有任何好感。 我也尝试在 wsl2 上部署了一下 docker，然而由于没有 s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-08T15:04:03.000Z"}],["meta",{"property":"article:tag","content":"工具"}],["meta",{"property":"article:published_time","content":"2023-11-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-08T15:04:03.000Z"}]]},"git":{"createdTime":1699771501000,"updatedTime":1751987043000,"contributors":[{"name":"lxl66566","username":"lxl66566","email":"18259734087@163.com","commits":17,"url":"https://github.com/lxl66566"}]},"readingTime":{"minutes":9.39,"words":2817},"filePathRelative":"coding/container.md","localizedDate":"2023年11月12日","excerpt":"\\n","autoDesc":true}');export{m as comp,u as data};
