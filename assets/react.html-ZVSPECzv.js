import{_ as t,e as a,f as r,o as s}from"./app-DoDz5hLc.js";const i={};function n(o,e){return s(),a("div",null,e[0]||(e[0]=[r('<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h1><p>初学，包含的东西较少。等到我真正用 React 开发一个项目的时候，这一页的东西才会变多起来。</p><h2 id="jsx-基础" tabindex="-1"><a class="header-anchor" href="#jsx-基础"><span>JSX 基础</span></a></h2><p>JSX 是 React 的核心，JSX 将一个 html 标签也视为一个 js object。</p><ul><li>多行 JSX 需要用括号包围；每个 JSX 只能是单标签，如果多标签则需要用 <code>&lt;&gt;&lt;/&gt;</code> 空标签包围。</li><li>JSX 内插值（插表达式）使用单大括号。</li><li>JSX 里的 class 要改为 className。</li><li>JSX 里可以写内联 style，接受一个类似 CSS 的对象。</li><li>JSX 里可以直接用 <code>&lt;div {...object} /&gt;</code> 进行 props 传入的解构，非常方便。</li></ul><p>JSX 能够非常灵活地组织组件，比 Vue 灵活太多了。</p><h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件"><span>组件</span></a></h2><p>一般来说只需要使用基于函数的 API。现在所有现代前端都在使用基于函数的 API，例如 Kotlin Compose UI，因为组合优于继承，灵活性非常强。</p><ul><li>React 每一个返回 JSX 对象的函数都是一个组件。</li><li>函数的第一个入参是 props。</li><li>如果要传递 JSX 给组件，默认传到 <code>props.children</code>。</li><li>组件间传值： <ul><li>父向子，props，没问题。</li><li>子向父，回调函数。</li></ul></li></ul><h2 id="react-hooks" tabindex="-1"><a class="header-anchor" href="#react-hooks"><span><a href="https://zh-hans.react.dev/reference/react/hooks" target="_blank" rel="noopener noreferrer">React Hooks</a></span></a></h2><p>Hooks 是响应式的基础。React 内置了许多 Hooks，但是平常最常用的也就 useState，useRef，useEffect。</p><h3 id="usestate" tabindex="-1"><a class="header-anchor" href="#usestate"><span>useState</span></a></h3><p>React 里最常用的响应式就是 useState 了。其返回两个值，<code>content</code> 是内容的引用 (getter)，<code>setContent</code> 是一个函数，用于改变内容 (setter)。这样可以比较明确地控制如何渲染 DOM 树。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">content</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setContent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;default content&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>和 SolidJS 不同，setContent 只有在实际值发生改变（<code>Object.is</code> 比较）时才会重新渲染。这或许在性能方面有优势，但对框架来说算是增加了（需要关注的）隐藏复杂度。</p><h3 id="usecontext" tabindex="-1"><a class="header-anchor" href="#usecontext"><span>useContext</span></a></h3><p>用于跨任意层组件向子组件方向传数据。随便看一个 <a href="https://zh-hans.react.dev/reference/react/useContext#usage" target="_blank" rel="noopener noreferrer">usage</a> 就会了。</p><p>React 19 后，可以用简化写法 <code>&lt;Context&gt;</code> 替代 <code>&lt;Context.Provider&gt;</code>。</p><h3 id="useref" tabindex="-1"><a class="header-anchor" href="#useref"><span>useRef</span></a></h3><p>跟 Vue 的 ref 有很大区别，useRef 这里的 ref 是不会触发渲染的。</p><p>有一点跟 Vue 一样的就是 Vue 的 ref 需要 <code>.value</code> 获取内部值，而 useRef 需要 <code>.current</code> 获取。</p><h3 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span>useCallback</span></a></h3><p>包装函数，让组件重新渲染时，该函数不会重新创建，也就是保持同一个对象。可以用于 <code>memo</code>。</p><h3 id="usereducer" tabindex="-1"><a class="header-anchor" href="#usereducer"><span>useReducer</span></a></h3><p>useReducer 和 useState 很像，只不过可以把状态更新逻辑从事件处理函数中移动到组件外部。<a href="https://zh-hans.react.dev/reference/react/useReducer#adding-a-reducer-to-a-component" target="_blank" rel="noopener noreferrer">src</a></p><h2 id="router" tabindex="-1"><a class="header-anchor" href="#router"><span>Router</span></a></h2><ul><li>React 最常用的 router 是 <a href="https://github.com/remix-run/react-router" target="_blank" rel="noopener noreferrer">React Router</a>。</li><li>如果你不使用高级功能，只是进行简单切换，也可以使用 <a href="https://github.com/molefrog/wouter" target="_blank" rel="noopener noreferrer">wouter</a>，更精简。</li></ul><h2 id="external" tabindex="-1"><a class="header-anchor" href="#external"><span>external</span></a></h2><ul><li><a href="https://juejin.cn/post/7195513281228898363" target="_blank" rel="noopener noreferrer">2023 再看 React 状态管理库</a></li></ul>',29)]))}const l=t(i,[["render",n],["__file","react.html.vue"]]),h=JSON.parse('{"path":"/coding/react.html","title":"React","lang":"zh-CN","frontmatter":{"date":"2025-01-04T00:00:00.000Z","icon":"brands fa-react","category":["编程"],"tag":["框架","前端"],"description":"React 初学，包含的东西较少。等到我真正用 React 开发一个项目的时候，这一页的东西才会变多起来。 JSX 基础 JSX 是 React 的核心，JSX 将一个 html 标签也视为一个 js object。 多行 JSX 需要用括号包围；每个 JSX 只能是单标签，如果多标签则需要用 <></> 空标签包围。 JSX 内插值（插表达式）使用单...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-04T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-28T17:37:12.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://absx.pages.dev/coding/react.html"}],["meta",{"property":"og:site_name","content":"绝对值_x 的博客"}],["meta",{"property":"og:title","content":"React"}],["meta",{"property":"og:description","content":"React 初学，包含的东西较少。等到我真正用 React 开发一个项目的时候，这一页的东西才会变多起来。 JSX 基础 JSX 是 React 的核心，JSX 将一个 html 标签也视为一个 js object。 多行 JSX 需要用括号包围；每个 JSX 只能是单标签，如果多标签则需要用 <></> 空标签包围。 JSX 内插值（插表达式）使用单..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-28T17:37:12.000Z"}],["meta",{"property":"article:tag","content":"前端"}],["meta",{"property":"article:tag","content":"框架"}],["meta",{"property":"article:published_time","content":"2025-01-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-28T17:37:12.000Z"}]]},"git":{"createdTime":1736014766000,"updatedTime":1751132232000,"contributors":[{"name":"lxl66566","username":"lxl66566","email":"lxl66566@gmail.com","commits":5,"url":"https://github.com/lxl66566"}]},"readingTime":{"minutes":2.31,"words":693},"filePathRelative":"coding/react.md","localizedDate":"2025年1月4日","excerpt":"\\n","autoDesc":true}');export{l as comp,h as data};
