import{_ as d,r as t,o,c as k,a as s,d as a,w as l,b as i,g as n,e}from"./app-Bj7F573k.js";const c={},g=e('<h1 id="rust" tabindex="-1"><a class="header-anchor" href="#rust"><span>Rust</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>Rust 是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust 在语法上和 C++类似，但是设计者想要在保证性能的同时提供更好的内存安全。——<a href="https://baike.baidu.com/item/Rust%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener noreferrer">百度百科</a></p><p>rust 掀起了一股 RIIR (Rewrite it in Rust) 的热潮。</p><p><a href="https://github.com/TaKO8Ki/awesome-alternatives-in-rust" target="_blank" rel="noopener noreferrer">Awesome Alternatives in Rust</a> | <a href="https://github.com/sts10/rust-command-line-utilities" target="_blank" rel="noopener noreferrer">A curated list of command-line utilities written in Rust</a> 收录了一些 rust 优秀应用。主要是 linux cli 工具。</p><h3 id="为什么推荐" tabindex="-1"><a class="header-anchor" href="#为什么推荐"><span>为什么推荐</span></a></h3><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h4>',7),u=s("ul",null,[s("li",null,"高性能（系统级语言）"),s("li",null,"安全，生命周期与所有权机制"),s("li",null,[i("开发社区激进，更新频繁，讨论环境良好（tg: "),s("a",{href:"https://t.me/rust_zh",target:"_blank",rel:"noopener noreferrer"},"@rust_zh"),i("）")]),s("li",null,[i("统一的代码格式、文档、测试、打包流程 "),s("ul",null,[s("li",null,"唯一指定顶级包管理器：cargo")])]),s("li",null,"易于打包"),s("li",null,[i("静态检查给力，能过 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≈")]),s("annotation",{encoding:"application/x-tex"},"\\approx")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4831em"}}),s("span",{class:"mrel"},"≈")])])]),i(" 能跑")])],-1),B=s("h4",{id:"缺点",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#缺点"},[s("span",null,"缺点")])],-1),b=s("li",null,"限制条件多，难以通过编译",-1),y=s("li",null,"学习曲线陡峭",-1),m=s("li",null,"开发周期长",-1),f=s("li",null,"GUI 库有待进步",-1),A=e('<h3 id="如何学习" tabindex="-1"><a class="header-anchor" href="#如何学习"><span>如何学习</span></a></h3><p><a href="https://www.rust-lang.org/zh-CN/" target="_blank" rel="noopener noreferrer">官网</a>有详细的 QA 与你所需要的一切。资料方面，rust 的学习资料非常多，列举几个我读过的：<a href="#external">external - book</a></p><ul><li>我在学习初期，先读资料，然后尝试用 Rust 去解 leetcode 上的<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>题目，看题解以后去<a href="https://doc.rust-lang.org/std/index.html" target="_blank" rel="noopener noreferrer">文档</a>进一步搜关键字和用法。</li><li>中后期就完全在做项目了，遇到不会的就去 <a href="https://t.me/rust_zh" target="_blank" rel="noopener noreferrer">Telegram 群</a>问。</li></ul><p>其他资料：</p><ul><li><a href="https://lib.rs/new" target="_blank" rel="noopener noreferrer">Rust new libraries and applications</a></li></ul><h2 id="开发环境" tabindex="-1"><a class="header-anchor" href="#开发环境"><span>开发环境</span></a></h2><h3 id="安装-rust" tabindex="-1"><a class="header-anchor" href="#安装-rust"><span>安装 rust</span></a></h3><p>rust 的安装与配置并不难。在 windows 上可以使用官方脚本一行安装 rustup 及 rust。linux 也可以选择用包管理器，详见 <a href="https://wiki.archlinuxcn.org/wiki/Rust" target="_blank" rel="noopener noreferrer">Archwiki</a>；但是最为推荐的还是 rustup，毕竟写 rust 会经常换工具链。</p><p>使用 rustup 的好处是支持交叉编译；方便切换 nightly。坏处是不通过包管理器更新，容易忘。</p><h3 id="开发" tabindex="-1"><a class="header-anchor" href="#开发"><span>开发</span></a></h3>',10),F=e(`<ul><li><code>rust-analyzer</code>，开发必备</li><li>(optional) <code>Rust Feature Toggler</code>，方便切换 features</li><li>(optional) <s><code>crates</code></s> （已改名为 <code>Dependi</code> <sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>），更好管理依赖版本</li></ul><p>还有一些能够优化开发体验的选项：</p><ol><li><a href="https://code.visualstudio.com/docs/languages/rust#_linting" target="_blank" rel="noopener noreferrer">使用 clippy</a> 作为 check 指令。</li><li>安装<a href="#%E6%89%A9%E5%B1%95">额外的 cargo 组件</a></li><li><s>切换 vscode <code>rust-analyzer</code> 插件为预发布版本</s> 算了，预发布经常出 bug。</li><li>设置 cargo fmt（<a href="https://github.com/lxl66566/git-simple-encrypt/blob/main/rustfmt.toml" target="_blank" rel="noopener noreferrer">我常用的</a>） <ul><li><a href="https://rust-lang.github.io/rustfmt/?version=v1.6.0&amp;search=#wrap_comments" target="_blank" rel="noopener noreferrer">开启注释自动换行</a>。由于其默认不开启且还停留在 unstable（五年啊！），因此需要自行写个 <code>rustfmt.toml</code> 开启。查看 <a href="#cargo">cargo</a> 小节获取更多 rustfmt 信息。</li><li>自动处理与合并 use 句</li></ul></li></ol><h2 id="语言基础" tabindex="-1"><a class="header-anchor" href="#语言基础"><span>语言基础</span></a></h2><h3 id="循环" tabindex="-1"><a class="header-anchor" href="#循环"><span>循环</span></a></h3><p>Rust 的 for 循环需要跟可迭代对象，例如：</p><div class="language-rs line-numbers-mode" data-highlighter="shiki" data-ext="rs" data-title="rs" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// i in [0,99]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">..=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">100.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">step_by</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// i in { 0,2,4,6...,98,100 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>而类似 C++ 的 do while 循环可以写成：</p><div class="language-rs line-numbers-mode" data-highlighter="shiki" data-ext="rs" data-title="rs" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">loop</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // do something</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> condition</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>loop 循环还可以 break 出一个值。</p><h3 id="输出" tabindex="-1"><a class="header-anchor" href="#输出"><span><a href="https://doc.rust-lang.org/rust-by-example/hello/print.html" target="_blank" rel="noopener noreferrer">输出</a></span></a></h3><p><code>dbg!()</code> 宏可以在 <code>stderr</code> 中输出调试信息，会消耗所有权。<code>dbg!</code> 返回值就是输入。<code>dbg!</code> 在 release 下也会输出。</p><p><code>ln</code> 代表结束空行。常用的就 <code>print(ln)!</code> <code>eprint(ln)!</code>，没了。<code>print</code> 系列宏不消耗所有权。<code>print!</code> 底层是 <code>write!</code>。</p><h3 id="输入" tabindex="-1"><a class="header-anchor" href="#输入"><span>输入</span></a></h3><p>输入需要使用标准库中的 <code>std::io</code>（或者其他非标准库），输入是各行的字符串，需要手动处理。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">io;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">io</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">stdin</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">read_line</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">expect</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;failed to read&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> num</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> i32</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">trim</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">unwrap</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 转换类型过程</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基础数据结构" tabindex="-1"><a class="header-anchor" href="#基础数据结构"><span>基础数据结构</span></a></h3><p><a href="https://skyao.io/learning-rust/docs/grammar/collection.html" target="_blank" rel="noopener noreferrer">这里</a>可能会有一些帮助。</p><ul><li>栈：Vec. 使用 <code>push()</code> &amp; <code>pop()</code> 管理栈。</li><li>（双端）队列：<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html" target="_blank" rel="noopener noreferrer"><code>std::collections::VecDeque</code></a></li><li>优先队列（堆）：<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html" target="_blank" rel="noopener noreferrer"><code>std::collections::BinaryHeap</code></a><ul><li><a href="https://internals.rust-lang.org/t/why-not-use-d-ary-heap-inside-rather-than-binary-heap/18765" target="_blank" rel="noopener noreferrer">Why not use d-ary heap inside rather than binary heap</a>，因此工程实践中可以不用 BinaryHeap。</li></ul></li><li>字典 / Object / map（键值对）：<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" target="_blank" rel="noopener noreferrer"><code>std::collections::HashMap</code></a></li><li>链表：<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html" target="_blank" rel="noopener noreferrer"><code>std::collections::LinkedList</code></a>，但是其功能在所有权机制下被削弱了（例如，无法删除一个 iter 的值 (safe)）。rust 并不推荐使用链表，如果确实需要完整链表，可以<s>自己写</s>去 <a href="https://crates.io" target="_blank" rel="noopener noreferrer">https://crates.io</a> 多翻翻。<a href="https://jasonkayzk.github.io/2022/02/20/%E4%BD%BF%E7%94%A8Rust%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" target="_blank" rel="noopener noreferrer">对于链表的实现，在 Rust 中有多种方式，比如：（摘自）</a><ul><li>使用 Box 实现（由于 Box 本身的限制，基本只能实现单向链表）；</li><li>使用 Rc + RefCell 实现（由于 RefCell 的限制，迭代器无法很好的实现）；</li><li>使用 Unsafe 实现；</li></ul></li></ul><p>不得不说手写数据结构确实是一个学习 rust 的好方式，自己写一遍，什么 *Cell 什么 Weak 全部都能吃透。</p><h3 id="container" tabindex="-1"><a class="header-anchor" href="#container"><span>container</span></a></h3><ul><li><a href="https://github.com/usagi/rust-memory-container-cs" target="_blank" rel="noopener noreferrer">Rust Memory Container Cheat-sheet</a></li></ul><h3 id="monad" tabindex="-1"><a class="header-anchor" href="#monad"><span>monad</span></a></h3><p>此处特指 <code>Option</code> 与 <code>Result</code> 两种。后面的方法可以不记，实际写到再查（IDE 下拉列表看函数签名）。</p><ul><li>取出值就是 <code>unwrap()</code>，有几个变体。注意会消耗所有权。</li><li>对内部映射，<code>map()</code> &amp; <code>map_err()</code></li><li>后面继续接 monad：<code>and_then()</code></li><li>取出值的引用，可变就 <code>as_mut()</code>，不可变就 <code>as_ref()</code>。 <ul><li>字符串特殊一点，<code>Option&lt;String&gt;</code> 转 <code>Option&lt;&amp;str&gt;</code> 需要 <code>as_deref()</code>。</li></ul></li><li>进阶一点，<code>Option&lt;Option&lt;T&gt;&gt;</code> 可以 <code>flatten()</code>，<code>Option&lt;Result&lt;T, E&gt;&gt;</code> 可以 <code>transpose()</code>，等等。可以读手册。</li></ul><h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串"><span>字符串</span></a></h3><p><em>Rust 的字符串所包含的问题实际上很多，此处只是冰山一角。</em></p>`,27),E=e(`<p>最主要的就是 <code>&amp;str</code> 和 <code>String</code> 两种了，前者没有所有权，后者有。</p><ul><li>Rust 字符串默认支持分行。使用 \\ 可以使多行字符串不换行。</li><li>Raw String：<code>r#&quot;\\something&quot;#</code></li><li>字符串转换：<code>to_owned()</code> or <code>to_string()</code> converts <code>&amp;str</code> -&gt; <code>String</code>（造了一个所有权）。也可以用 <code>into()</code>，更简单，但是更不直观。</li><li><a href="https://iq.opengenus.org/rust-string-concat/" target="_blank" rel="noopener noreferrer">字符串连接</a></li></ul><h4 id="字符串修改" tabindex="-1"><a class="header-anchor" href="#字符串修改"><span>字符串修改</span></a></h4><p>在 Rust 语言中，字符串采用 utf-8 编码，字符长度不一，因此 Rust 不提供下标查找字符串的方法。这让字符串的修改需要一点点的技巧。</p><ol><li>转换为<code>Vec&lt;char&gt;</code>后修改 C++程序员认为这种方式非常亲切。之后若有需要，还可将<code>Vec&lt;char&gt;</code>重新转换为字符串。注意，Rust 中的 <code>char</code> 为 4 字节，转为 Vec 后，可进行 O(1) 查找。<div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello我是绝对值_x&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Vec</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">chars</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">collect</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;你&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s2</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">iter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">collect</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">assert_eq!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello你是绝对值_x&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>replace_range 函数<div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello我是绝对值_x&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">replace_range</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">..=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;你&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">assert_eq!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello你是绝对值_x&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>请注意，若替换范围不在 utf-8 字符的分割点上将会导致程序抛出 panic，因此不适用于变字节数的未知字符串的替换。</li><li>as_bytes_mut 方法(<strong>unsafe</strong>)<div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello我是绝对值_x&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s1_bytes</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">u8</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">as_bytes_mut</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s2_bytes</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">u8</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;你&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">as_bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    s1_bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s2_bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">assert_eq!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello你是绝对值_x&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>该方法异常繁琐，同样也不适用于变字节数的未知字符串的替换，但是若替换范围不在 utf-8 字符的分割点上并不会触发 panic. 例如，将第 6 行代码改为<code>s1_bytes[i + 6] = s2_bytes[i]</code>的运行结果：<div class="language-rust" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Hello</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">�你��绝对值_x</span></span></code></pre></div></li></ol><h4 id="其他字符串" tabindex="-1"><a class="header-anchor" href="#其他字符串"><span>其他字符串</span></a></h4>`,6),v=s("li",null,[s("code",null,"std::path::{Path, PathBuf}"),i(" 是路径字符串。"),s("code",null,"Path"),i(" 没有所有权，"),s("code",null,"PathBuf"),i(" 有所有权。")],-1),C=s("code",null,"url::Url",-1),_=e(`<h3 id="语法糖" tabindex="-1"><a class="header-anchor" href="#语法糖"><span>语法糖</span></a></h3><h4 id="问号" tabindex="-1"><a class="header-anchor" href="#问号"><span>问号</span></a></h4><div class="subtitle">——多用问号 人生会轻松很多</div><p>问号用于提前返回错误。<code>do_something_that_might_fail()?</code> 等价于</p><div class="language-rs line-numbers-mode" data-highlighter="shiki" data-ext="rs" data-title="rs" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">match</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> do_something_that_might_fail</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">  Ok</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> v</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">  Err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问号不能在正常签名的闭包中使用，例如 <code>for_each</code>，<code>map</code> 等的参数。可以用 <code>try_for_each</code>，<code>try_map</code> 等（如果有的话）。</p><p>或者等他娘的 <a href="https://github.com/rust-lang/rust/issues/31436" target="_blank" rel="noopener noreferrer">try_blocks</a> 稳定。</p><h4 id="impl-trait" tabindex="-1"><a class="header-anchor" href="#impl-trait"><span>impl Trait</span></a></h4><p>匿名泛型，可以让你少写点东西。</p><div class="language-rs line-numbers-mode" data-highlighter="shiki" data-ext="rs" data-title="rs" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> impl</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> IntoIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Item</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> impl</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> fmt</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Display</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    a</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">into_iter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">for_each</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> println!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// equals to:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">where</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    T</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> IntoIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    T</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Item</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> fmt</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Display</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    a</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">into_iter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">for_each</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> println!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="并发" tabindex="-1"><a class="header-anchor" href="#并发"><span>并发</span></a></h3><blockquote><p>如果你对 <em>async/await</em> 模型没有明确概念，可以看看<a href="https://course.rs/advance/async/getting-started.html" target="_blank" rel="noopener noreferrer">这篇文章</a>入门。<br> rust 提供 <em>async/await</em> 模型和线程模型。</p></blockquote><h4 id="future" tabindex="-1"><a class="header-anchor" href="#future"><span>Future</span></a></h4><p>每个 async 函数返回的都是一个 <code>Future&lt;Output = ...&gt;</code>。Rust 的 Future 不像其他语言那样创建即执行，而是需要通过 poll 执行并推进。</p><ul><li>手写 Future 要注意，如果返回 <code>Poll::Pending</code>，必需要在前面调一次 wake。</li><li>手动 <code>impl Future for Xxx</code> 比较复杂，要手写状态机，因此如果不是写底层库，一般就 <code>impl Xxx { async fn call() }</code>，虽然调用时不能直接 <code>.await</code> 而需要 <code>.call().await</code>，但是能够极大降低心智负担。</li></ul><h4 id="send-sync" tabindex="-1"><a class="header-anchor" href="#send-sync"><span>Send/Sync</span></a></h4><p>关于 Send/Sync 可以看<a href="https://kaisery.github.io/trpl-zh-cn/ch16-04-extensible-concurrency-sync-and-send.html" target="_blank" rel="noopener noreferrer">这里</a> 或者 <a href="#external">external articles 5.</a>。</p><ul><li>另一个理解是：Send：对象的 &amp;mut 和析构能在别的线程访问；Sync：对象的 &amp; 能在别的线程访问 ——<a href="https://t.me/c/1264662201/571556" target="_blank" rel="noopener noreferrer">包布丁</a></li></ul><p>关于 Wrappers，看这里即可（我想大家应该都看得懂）:</p><table><thead><tr><th>Struct</th><th>Trait</th></tr></thead><tbody><tr><td><code>Box&lt;T&gt;</code></td><td>Send(T) -&gt; Send, Sync(T) -&gt; Sync</td></tr><tr><td><code>Arc&lt;T&gt;</code></td><td>(Send + Sync)(T) -&gt; (Send + Sync)</td></tr><tr><td><code>Mutex&lt;T&gt;</code></td><td>Send(T) -&gt; (Send + Sync)</td></tr><tr><td><code>Rc</code></td><td>!Send + !Sync</td></tr><tr><td><code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code></td><td>Send(T) -&gt; Send, !Sync</td></tr><tr><td><code>RwLock&lt;T&gt;</code></td><td>(Send + Sync)(T) -&gt; (Send + Sync), Send(T) -&gt; Send</td></tr></tbody></table><blockquote><p>此处暂不考虑 allocator.</p></blockquote><p>将这些类型列在一起，可以发现，标准库没有任何包装可以将 <code>!Send</code> 转为 <code>Send</code>。（貌似有一个 crate <a href="https://crates.io/crates/send_wrapper" target="_blank" rel="noopener noreferrer">send_wrapper</a> 可以做到）</p><h4 id="tokio" tabindex="-1"><a class="header-anchor" href="#tokio"><span>tokio</span></a></h4><p>说到并发，目前广泛使用的异步运行时是 tokio。一般 <code>features = [&quot;macros&quot;, &quot;rt&quot;, &quot;rt-multi-thread&quot;]</code> 是必加的。</p><p>关于 tokio 可以看<a href="https://rust-book.junmajinlong.com/ch100/01_understand_tokio_runtime.html" target="_blank" rel="noopener noreferrer">入门秘籍 13 章</a>。</p><ul><li>立即执行 Future 需要用 <code>spawn</code>。否则只会在 await 时执行。</li><li>计算密集型任务请用 <code>spawn_blocking</code>，性能提升巨大。spawn_blocking 的默认最大线程数也是很高的（<a href="https://github.com/tokio-rs/tokio/discussions/3858#discussioncomment-869878" target="_blank" rel="noopener noreferrer">约 512</a>），必要时也可以调小 blocking 池的大小，将任务更合理地分配给 physical thread。</li></ul><h4 id="简单批处理" tabindex="-1"><a class="header-anchor" href="#简单批处理"><span>简单批处理</span></a></h4><p>在实际并发中经常碰到需要等待一批 Future 结束并获取返回值的情况。<code>join!</code> 不能 join 任意数量；tokio 有一个 <code>JoinSet</code>，但返回值是乱序的，并且 api 设计也不够易用。所以我们如何获取顺序的并行 Future 返回值呢？</p><p>答：用 <code>futures</code> / <code>futures_util</code> crate 的 <code>futures::stream::FuturesUnOrdered</code>。具体使用方法可以参考<a href="https://github.com/tensorlakeai/indexify/blob/5999be8514a4a6595aea72ec790cb526cc5ff0ac/src/blob_storage/disk.rs#L48" target="_blank" rel="noopener noreferrer">用例</a>。一般就是将每一个 task spawn，然后将 handle collect 到 FuturesUnOrdered 里再 <code>while let Some(x) = container.next().await</code> 即可。</p><h3 id="mod" tabindex="-1"><a class="header-anchor" href="#mod"><span>mod</span></a></h3><p>rust 的 mod 确实会让人摸不着头脑。建议先搜几篇文章看看：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/73544030" target="_blank" rel="noopener noreferrer">Rust 模块和文件 - [译]</a></li></ul><p>然后以下是我的一些浅薄理解，可能不正确，请自行分辨：</p><ol><li>每一个 <strong><code>.rs</code>文件</strong> 和 <strong>带有 <code>mod.rs</code> 的文件夹</strong> 都是模块。</li><li><code>main.rs</code> 是顶层模块(<code>crate</code>)，其他模块层级即为<strong>文件目录层级</strong>。</li><li>mod 后若不跟代码块，则<strong>声明当前模块与<mark>低层级</mark>模块的依赖关系</strong>；若跟代码块，则<strong>在当前模块中声明定义一个子模块</strong>。</li></ol><p>例如我有一个文件结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>.</span></span>
<span class="line"><span>|-- config.rs</span></span>
<span class="line"><span>|-- core</span></span>
<span class="line"><span>|   |-- cambridge_en_zh.rs</span></span>
<span class="line"><span>|   \`-- mod.rs</span></span>
<span class="line"><span>|-- main.rs</span></span>
<span class="line"><span>\`-- request.rs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>则 <code>main.rs</code> 为 0 级模块，<code>config.rs</code> &amp; <code>request.rs</code> &amp; <code>core</code> 为 1 级模块，<code>cambridge_en_zh.rs</code> 为 2 级模块。</p><p>在某个模块中使用 <code>mod</code> 语句只能声明<strong>更低级</strong>的模块关系。例如，我不能在 <code>request.rs</code> 中使用 <code>mod core;</code>，因为它俩同级（1 级）。</p><p>那我们怎样在 <code>request.rs</code> 中使用 <code>core</code> 的内容呢？这就要通过更高级的模块进行中转：</p><div class="language-rs line-numbers-mode" data-highlighter="shiki" data-ext="rs" data-title="rs" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// main.rs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">mod</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">mod</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;"> core</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// request.rs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> crate</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">core;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// or \`use super::core;\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="trait" tabindex="-1"><a class="header-anchor" href="#trait"><span>trait</span></a></h3><p>trait 可谓是 rust 核心，不是 OOP 胜似 OOP(?)，rust 学习的一大难点也是掌握 trait 的用法。</p><ul><li>trait 在一些方面有点像其他语言的 interface，但脱离了继承的限制，可以随时创建，随时 implement，trait 之间不需要有联系。</li><li>trait 可以为现有的结构<strong>附加方法</strong>，这是多数强类型语言所不具备的。</li><li>trait 简化了泛型的实现。（点名 C++ (&lt;20)）</li><li>trait 可以“继承”，指 impl 其他 trait 后才能 impl 这个 trait。最经典的就是 <code>Eq</code> 需要 <code>PartialEq</code>。</li><li>trait 本身也是一个类型，可以 <code>impl trait for trait</code>:<div class="language-rs line-numbers-mode" data-highlighter="shiki" data-ext="rs" data-title="rs" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> trait</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Process</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> trait</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Takable</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> take</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Takable</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> T</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">where</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">  T</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Process</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> take</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    self</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>但是从其他模块调用 take 时需要 <code>use &lt;mod_name&gt;::Takable</code>。</li></ul></li><li><a href="https://juejin.cn/post/7302359255330504739" target="_blank" rel="noopener noreferrer">TAIT</a>：Trait alias.</li></ul><h3 id="dyn-object" tabindex="-1"><a class="header-anchor" href="#dyn-object"><span>dyn object</span></a></h3><p>一个特殊的对象是 dyn object，表示实现了某个 trait 的任意对象。开销比特定类型对象大一点，但是非常好用。</p><p>一般要求 Sized，所以要么 <code>dyn object + Sized</code>，要么 <code>Box&lt;dyn object&gt;</code>。如果在 struct 内用，经常还需要加生命周期。虽然要求这么多，但是真正用到才发现好用。泛型写一大串不如直接 dyn 秒了。</p><ul><li>dyn 在写异步时非常好用。异步经常需要跟 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 打交道，而我们不能直接从 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 拿到 T，假设变换过程中随便加一个中间结构（例如 <code>std::iter::Map</code>），然后就会变成 <code>Map&lt;Pin&lt;Box&lt;T&gt;&gt;&gt;</code>，如果又要 awaitable 又会转成 <code>Pin&lt;Box&lt;Map&lt;Pin&lt;Box&lt;T&gt;&gt;&gt;&gt;&gt;</code>，套来套去泛型根本没法处理。</li></ul><h3 id="宏" tabindex="-1"><a class="header-anchor" href="#宏"><span>宏</span></a></h3><p>宏是很好用的东西，分为过程宏和声明宏。声明宏简单，常见用来写不定参数的函数/减少重复代码。过程宏就是纯 Token 处理，非常复杂，可以写装饰器。</p><p>学习宏，直接去看<a href="#%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0">如何学习</a>中提到的小宏书。讲的很好。</p><p>调试宏可以用 <a href="#%E6%89%A9%E5%B1%95">cargo-expand</a>，不需要通过编译就能展开宏。</p><ul><li>不加 <code>#[macro_export]</code> 的话，定义的宏仅在当前 mod 可用。</li><li>在其他宏里调非卫生宏不能直接用，需要加 <code>$crate</code> 显式指定路径。</li><li>可以定义同名宏重载系统宏，但是注意不能在同名宏里调用被重载的系统宏，否则递归。<a href="https://github.com/Xavientois/die/pull/3/files" target="_blank" rel="noopener noreferrer">example</a></li><li><a href="https://docs.rs/safe_arch/latest/safe_arch/#a-note-on-working-with-cfg" target="_blank" rel="noopener noreferrer">A Note On Working With Cfg</a></li><li>有几个标签类型可以被重解释（<code>ident</code>, <code>tt</code> 等），非常强大。</li><li>匹配写不出来就上 <code>$(tt)*</code>，啥都能匹配。但是由于 tt 太强，需要注意边界条件，否则把所有 token 全吃了。</li></ul><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3><ul><li>可以显式调用 <a href="https://kaisery.github.io/trpl-zh-cn/ch15-03-drop.html#%E9%80%9A%E8%BF%87-stdmemdrop-%E6%8F%90%E6%97%A9%E4%B8%A2%E5%BC%83%E5%80%BC" target="_blank" rel="noopener noreferrer"><code>std::mem::drop()</code></a> 释放值，不过一般使用代码块，让变量自动销毁，会更加清晰。<a href="https://xuanwo.io/reports/2022-41/" target="_blank" rel="noopener noreferrer">更多详细解释</a></li><li>不知道结构体多大？rust-analyzer 有选项能直接看，将光标放在结构体上，（vscode 中 Ctrl + Shift + P）选择 <em>view memory layout</em> 即可。</li></ul><h2 id="cargo" tabindex="-1"><a class="header-anchor" href="#cargo"><span>Cargo</span></a></h2><p>rust 唯一官方指定包管理器：<code>cargo</code>，而且在一众语言包管理中是顶级的。</p><ul><li>cargo 的 dep 版本中，<code>xxx = 1.2.1</code> 指的其实是 <code>&gt;= 1.2.1, &lt;2.0.0</code>，与 npm 中的 <code>^1.2.1</code> 一致。(<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-cratesio" target="_blank" rel="noopener noreferrer">ref</a>)</li></ul><h3 id="cargo-envs" tabindex="-1"><a class="header-anchor" href="#cargo-envs"><span><a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html" target="_blank" rel="noopener noreferrer">cargo envs</a></span></a></h3><h3 id="全局-alias" tabindex="-1"><a class="header-anchor" href="#全局-alias"><span>全局 alias</span></a></h3><p>创建 <code>~/.cargo/config.toml</code> 并写入：</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;build&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;check&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;test -- --nocapture&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;run&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">u</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;update&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;fix --allow-dirty&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="fmt" tabindex="-1"><a class="header-anchor" href="#fmt"><span>fmt</span></a></h3><p>在 <code>rustfmt.toml</code> 里写代码的格式化选项。我一般只开 <code>wrap_comments</code>，不过也可以直接抄<a href="https://github.com/compio-rs/winio/blob/master/rustfmt.toml" target="_blank" rel="noopener noreferrer">前辈的</a>。</p><h3 id="构建" tabindex="-1"><a class="header-anchor" href="#构建"><span>构建</span></a></h3><p>cargo build 在全局获取包与依赖的源码，并编译到 target 里。rust 的包构建体积膨胀非常厉害，而且同一份源码的编译产物可能不同<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>，因此没有全局缓存，还是需要为每个仓库都编出中间产物。</p><p>不过可以试试 <a href="https://github.com/mozilla/sccache/" target="_blank" rel="noopener noreferrer">sccache</a> 全局缓存。</p><h3 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展"><span>扩展</span></a></h3><p>cargo 扩展跟 git 扩展很像，只要是名为 <code>cargo-xxx</code> 的可执行文件都能视作 cargo 扩展。以下列举一些常用的 cargo 扩展应用。</p>`,68),D=e('<table><thead><tr><th>名字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://github.com/rust-lang/miri" target="_blank" rel="noopener noreferrer">miri</a></td><td><code>rustup +nightly component add miri</code>，用于更严格的测试，检测内存泄漏与不安全，死锁等</td></tr><tr><td><a href="https://github.com/cargo-bins/cargo-binstall" target="_blank" rel="noopener noreferrer">cargo-binstall</a></td><td>安装 binary，减少从源码编译</td></tr><tr><td><a href="https://github.com/RazrFalcon/cargo-bloat" target="_blank" rel="noopener noreferrer">cargo-bloat</a></td><td>Find out what takes most of the space in your executable.</td></tr><tr><td><a href="https://github.com/dtolnay/cargo-expand" target="_blank" rel="noopener noreferrer">cargo-expand</a></td><td>展开宏</td></tr><tr><td><a href="https://github.com/foresterre/cargo-msrv" target="_blank" rel="noopener noreferrer">cargo-msrv</a></td><td>Find the minimum supported Rust version (MSRV) for your project</td></tr><tr><td><a href="https://github.com/Kobzol/cargo-wizard" target="_blank" rel="noopener noreferrer">cargo-wizard</a></td><td>提供编译模板以配置为最大性能、快速编译时间或最小二进制大小。感觉一般。</td></tr><tr><td><a href="https://github.com/flamegraph-rs/flamegraph" target="_blank" rel="noopener noreferrer">flamegraph</a></td><td>benchmark 火焰图</td></tr><tr><td><a href="https://github.com/rust-lang/cargo-bisect-rustc" target="_blank" rel="noopener noreferrer">cargo-bisect-rustc</a></td><td>二分查找哪个 rustc nightly 版本引入了错误</td></tr><tr><td><a href="https://github.com/Boshen/cargo-shear" target="_blank" rel="noopener noreferrer">cargo-shear</a> / <a href="https://github.com/bnjbvr/cargo-machete" target="_blank" rel="noopener noreferrer">cargo-machete</a></td><td>Remove unused Rust dependencies</td></tr><tr><td><a href="https://github.com/nextest-rs/nextest" target="_blank" rel="noopener noreferrer">cargo-nextest</a></td><td>好用的 test 工具，有超时失败，log 筛选等特性</td></tr><tr><td><a href="https://github.com/RustSec/rustsec/tree/main/cargo-audit" target="_blank" rel="noopener noreferrer">cargo-audit</a></td><td>查依赖漏洞</td></tr><tr><td><a href="https://crates.io/crates/cargo-hakari" target="_blank" rel="noopener noreferrer">cargo-hakari</a></td><td>加速构建的黑科技</td></tr><tr><td><a href="https://github.com/lusingander/cargo-selector" target="_blank" rel="noopener noreferrer">cargo-selector</a></td><td>TUI 快速选择运行目标</td></tr><tr><td><a href="https://github.com/holmgr/cargo-sweep" target="_blank" rel="noopener noreferrer">cargo-sweep</a></td><td>部分清理编译产物</td></tr><tr><td><a href="https://github.com/jplatte/cargo-depgraph" target="_blank" rel="noopener noreferrer">cargo-depgraph</a></td><td>看依赖关系。比 cargo-tree 等等好用</td></tr><tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks" target="_blank" rel="noopener noreferrer">cargo-semver-checks</a></td><td>检查 API 是否遵循 semver 规范</td></tr></tbody></table><h2 id="库" tabindex="-1"><a class="header-anchor" href="#库"><span>库</span></a></h2><p>多看热门项目用的库，是发现好用的库的好方法。还有一个方法是水群。</p><p>有一些库几乎成为业界标准，必需掌握。</p>',4),x=e('<table><thead><tr><th>库名</th><th>简介</th></tr></thead><tbody><tr><td>anyhow / thiserror</td><td>错误处理</td></tr><tr><td>tokio</td><td>异步</td></tr><tr><td>serde</td><td>序列化</td></tr><tr><td>reqwest<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup></td><td>简单网络</td></tr><tr><td>clap</td><td>命令行工具</td></tr><tr><td>tempfile</td><td>创建自动销毁的临时文件夹</td></tr></tbody></table><p>另外一些库则是我用过然后觉得好用。</p>',2),w=e(`<table><thead><tr><th>库名</th><th>简介</th></tr></thead><tbody><tr><td>memchr</td><td>字符串查找</td></tr><tr><td>assert2 / pretty_assertions</td><td>全兼容的好看的 assert</td></tr><tr><td>die-exit</td><td>错误处理并退出</td></tr><tr><td>tap</td><td>函数式工具，在链式中途拿取引用操作而不影响返回值</td></tr><tr><td>enum-tools</td><td>提供 enum 的常用方法</td></tr><tr><td>pollster</td><td>小而美，专注于 <em>在同步环境运行异步函数</em> 一件事</td></tr><tr><td>expect-test</td><td>自动更新 test 中 assert_eq 的期望值</td></tr><tr><td>indicatif</td><td>progress bar</td></tr><tr><td>const-hex</td><td><code>Vec&lt;u8&gt;</code> -&gt; hex str</td></tr><tr><td>constime</td><td>计算编译期值，用一个非常简单易用的宏</td></tr></tbody></table><p><a href="https://blessed.rs/crates" target="_blank" rel="noopener noreferrer">这里</a>还有一个常用库的列表可以参考。</p><h3 id="clap" tabindex="-1"><a class="header-anchor" href="#clap"><span>clap</span></a></h3><p>一般我都用 <code>features = [&quot;derive&quot;]</code>，使用更方便，但是文档更难找，因为文档默认用的是动态添加成员。<a href="https://github.com/lxl66566/wordinfo/blob/main/src/cli.rs" target="_blank" rel="noopener noreferrer">wordinfo</a> 的 Cli 简直是我的 clap 毕生所学（，折腾了非常久。</p><p>clap 可以跟 lazy_static 一起使用，将 CLI 设为 static，可以免去到处传参之苦。带来的问题是写测试变得更加困难。</p><h3 id="once-cell" tabindex="-1"><a class="header-anchor" href="#once-cell"><span>once_cell</span></a></h3><p>创建 Lazy 或 OnceCell 的 static 变量。在 rustc 1.80.0 以前这是 unstable，但是现已 stabilized（<code>std::sync::LazyLock</code>）。</p><h3 id="thiserror" tabindex="-1"><a class="header-anchor" href="#thiserror"><span>thiserror</span></a></h3><p>轻量错误库，用来创建自定义的 error 类型；可以自动 derive From another error。</p><p>不能在两个错误类型中同时 from 同一个 Error。如果确实需要，可能要手动再分 Enum 作为 suberror。</p><h3 id="serde" tabindex="-1"><a class="header-anchor" href="#serde"><span>serde</span></a></h3><p>除了直接 derive 外，serde 一般用得多的技巧还有：</p><ul><li><code>#[serde(rename = &quot;xx&quot;)]</code> 和 <code>#[serde(rename_all = &quot;kebab-case&quot;)]</code>，自定义序列化的名称与格式。更多宏可以看<a href="https://serde.rs/field-attrs.html" target="_blank" rel="noopener noreferrer">doc Field attributes</a>。</li><li>对于需要在缺失时使用 empty 的容器对象，<code>#[serde(default)]</code> 是个不错的选择。</li><li>如果有的结构需要手写 parser，可以顺带实现 serialize trait，代码不会太多。</li></ul><h2 id="打包" tabindex="-1"><a class="header-anchor" href="#打包"><span>打包</span></a></h2><p>说到打包就不得不提万恶的 openssl，我已经<a href="https://t.me/withabsolutex/1609" target="_blank" rel="noopener noreferrer">喷了无数次</a>，<a href="https://t.me/withabsolutex/1859" target="_blank" rel="noopener noreferrer">无数次</a>…。很多库会提供 rustls feature 来绕过 openssl，例如 reqwest；但是也有库根本不提供，例如 rusqlite。所以 openssl 的问题还是得去解决。</p><h3 id="最小化二进制" tabindex="-1"><a class="header-anchor" href="#最小化二进制"><span><a href="https://github.com/johnthagen/min-sized-rust" target="_blank" rel="noopener noreferrer">最小化二进制</a></span></a></h3><p>一般这样够用了。<s>我虽然敏感，但没有 no-std 那么极端。</s></p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">profile</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">release</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">strip</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">opt-level</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;z&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">lto</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">panic</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;abort&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者也可以看看 <a href="#%E5%BC%80%E5%8F%91">cargo-wizard</a>。</p><h3 id="交叉编译" tabindex="-1"><a class="header-anchor" href="#交叉编译"><span>交叉编译</span></a></h3><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">rustup</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> target</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> x86_64-unknown-linux-musl</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">cargo</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> --release</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> --target</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> x86_64-unknown-linux-musl</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我也写过 <a href="https://github.com/lxl66566/rust-simple-release" target="_blank" rel="noopener noreferrer">rust release CI</a>，深知交叉编译在 link 阶段很容易出问题。解法有两个，一个是用工具链对应的链接器，还有一个就是 cargo-zigbuild，蛮好用的。不过 windows 上不能用 cargo-zigbuild。</p><h3 id="release" tabindex="-1"><a class="header-anchor" href="#release"><span>release</span></a></h3><p>说到 release，我<strong>首推我自己写的 <a href="https://github.com/lxl66566/rust-simple-release" target="_blank" rel="noopener noreferrer">rust simple release</a></strong>，优势是配置非常简单 + hack openssl，可以专注代码而无需折腾 CI。</p><p>再说到我之前用的 <a href="https://github.com/marketplace/actions/build-and-upload-rust-binary-to-github-releases" target="_blank" rel="noopener noreferrer">taiki-e/upload-rust-binary-action</a>，我也用了很久，说句实话还行，但是它内部用的 cross docker container，如果有除了 rust 的其他依赖，或者遇到傻逼 openssl 的问题就没辙了。</p><p><a href="https://github.com/houseabsolute/actions-rust-cross" target="_blank" rel="noopener noreferrer">cross action</a>：使用 docker 容器进行 build，但是不提供压缩产物。</p><h2 id="发布" tabindex="-1"><a class="header-anchor" href="#发布"><span>发布</span></a></h2><p>将包发布到 crates.io 上也是极其方便的。直接 <code>cargo publish</code> 即可。</p><p>不过我不建议使用 CI 进行 publish。<a href="https://t.me/withabsolutex/1827" target="_blank" rel="noopener noreferrer">具体原因</a></p><h2 id="测试" tabindex="-1"><a class="header-anchor" href="#测试"><span>测试</span></a></h2><p>assert 有 <code>assert!()</code> 和 <code>debug_assert!()</code> 之分，前者在 release 下仍然会进行 assert，而后者不会。</p><p><a href="https://github.com/de-vri-es/assert2-rs" target="_blank" rel="noopener noreferrer">assert2</a> 是一个全兼容 assert 的更好看的第三方库，是 <a href="https://crates.io/crates/pretty_assertions" target="_blank" rel="noopener noreferrer">pretty_assertions</a> 进化版。</p><p>关于测试看<a href="https://course.rs/test/write-tests.html" target="_blank" rel="noopener noreferrer">这一篇</a>就够了。小总结/补充：</p><ul><li><code>#[cfg(test)]</code> 指非 test 情况下忽略代码，不会被编译。后面一般接 <code>mod test{ use super::*; ...}</code>。</li><li><code>#[test]</code> 后接函数，名称随意，就是真正的测试函数。</li><li>如果 target 是 bin，则写在 doc 中的测试不会被运行。</li><li><code>cargo test</code> 默认不打印 <em>stdout</em> 输出，想打印需要 <code>cargo test -- --show-output</code>。</li></ul><h3 id="cargo-bench" tabindex="-1"><a class="header-anchor" href="#cargo-bench"><span>cargo bench</span></a></h3><p>rust 自带的 benchmark。可以参考<a href="https://course.rs/test/benchmark.html" target="_blank" rel="noopener noreferrer">这篇文章</a>，讲的不错。</p><p>感觉 <code>criterion.rs</code> 并不好用。。毕竟不能写在文件内部做 unit bench，单独出来做成跟 pytest 那样了，我不喜欢。</p><h2 id="用户界面" tabindex="-1"><a class="header-anchor" href="#用户界面"><span>用户界面</span></a></h2><h3 id="gui" tabindex="-1"><a class="header-anchor" href="#gui"><span>GUI</span></a></h3><p>GUI 是 rust 日经问题了。</p><p>一些 GUI 框架：</p><ul><li>tauri：electron 的竞品，据说很灵车（许多群友都说过了）。 <ul><li>2022 年我试了一下，连 example 都跑不过。</li><li>2024 尝试，还不错。主要是前端工具链是 GUI 界最顶级的那一批，爆杀各类原生 UI。</li><li><a href="https://mp.weixin.qq.com/s/UxmJxU4-fv9GeRxl2fzOGw" target="_blank" rel="noopener noreferrer">得物商家客服从 Electron 迁移到 Tauri 的技术实践</a></li><li><a href="https://github.com/yetone/tauri-bug-reproducer" target="_blank" rel="noopener noreferrer">tauri-bug-reproducer</a>，T 黑头子（</li></ul></li><li><a href="https://github.com/emilk/egui" target="_blank" rel="noopener noreferrer">egui</a>：原生 GUI，有<a href="https://www.reddit.com/r/rust/comments/1c69mrj" target="_blank" rel="noopener noreferrer">大项目</a>。 <ul><li><a href="https://t.me/withabsolutex/2203" target="_blank" rel="noopener noreferrer">20250123 我用了一次 egui 0.3.0，太灵车了</a>，建议别用。</li><li>窗口 API，还有布局等等都很差，很多地方还要自己拿 size 算（还有缩放坑），太原始，前端一个 flex 全搞定了。而且 API 变化太大，AI 没法输出有效信息，这也是比较致命的。</li></ul></li><li><a href="https://github.com/slint-ui/slint" target="_blank" rel="noopener noreferrer">slint</a>：嗯写 DSL</li><li><a href="https://github.com/DioxusLabs/dioxus" target="_blank" rel="noopener noreferrer">dioxus</a>：也是嗯写 DSL。release 0.5.0 时火了一把</li><li><a href="https://github.com/gabdube/native-windows-gui" target="_blank" rel="noopener noreferrer">native-windows-gui</a>：非跨平台</li><li><a href="https://github.com/compio-rs/winio" target="_blank" rel="noopener noreferrer">winio</a>：<s>莓软的愚人节玩笑</s></li><li><a href="https://docs.rs/sciter-rs/latest/sciter/" target="_blank" rel="noopener noreferrer">sciter</a>：web 界面渲染</li></ul><p><a href="https://www.cnblogs.com/nolca/p/17795473.html" target="_blank" rel="noopener noreferrer">这里</a>有一些 issue/star 数对比。<a href="https://areweguiyet.com/" target="_blank" rel="noopener noreferrer">Are we GUI Yet?</a>是更多 GUI 框架简介。</p><p>我早期尝试过一下 iced，用不明白，不用了。</p><p><em>他们之中有哪个能达到 electron 80% 的可用程度，称为可用。</em></p><div style="text-align:right;"><p>——<em><a href="https://github.com/magic-akari" target="_blank" rel="noopener noreferrer">阿卡琳</a></em></p></div><h3 id="tui" tabindex="-1"><a class="header-anchor" href="#tui"><span>TUI</span></a></h3><p>比起 GUI，rust 重心还是在 CLI 和 TUI 上。</p><h4 id="ratatui" tabindex="-1"><a class="header-anchor" href="#ratatui"><span><a href="https://github.com/ratatui-org/ratatui" target="_blank" rel="noopener noreferrer">ratatui</a></span></a></h4><p>一个广泛使用的 TUI 框架，教程还不错。</p><p>我读源码花了挺久时间。如果只想快速上手，建议狠狠抄<a href="https://github.com/ratatui-org/templates/tree/main/simple-async" target="_blank" rel="noopener noreferrer">这个 example</a>。</p><p>用着发现个 bug，顺带 pr 了几行<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup>。</p><p>然后 <a href="https://github.com/veeso/tui-realm/" target="_blank" rel="noopener noreferrer">tui-realm</a> 是基于其做的一个高层 TUI 框架，或许可以一试。</p><h2 id="嵌入向量数据库" tabindex="-1"><a class="header-anchor" href="#嵌入向量数据库"><span>嵌入向量数据库</span></a></h2><p>我需要 rust 侧的轻量嵌入式向量数据库解决方案，要求是 10,000,000 个向量内查最近邻。（每个向量还有附带额外信息）</p><p>简单看了一下。我不希望将所有数据先加载到内存，最好的方案应该是 <a href="https://www.oschina.net/news/304024" target="_blank" rel="noopener noreferrer">DiskANN</a>，不过这玩意目前还没有 rust 的实现。</p><ul><li><a href="https://github.com/asg017/sqlite-vec" target="_blank" rel="noopener noreferrer">sqlite-vec</a>：sqlite 跨平台扩展，但是现在并不支持最近邻算法。</li></ul><h2 id="r18n" tabindex="-1"><a class="header-anchor" href="#r18n"><span>r18n</span></a></h2><p>去 luoxu <a href="https://luoxu.archlinuxcn.org/#g=1264662201&amp;q=i18n" target="_blank" rel="noopener noreferrer">随便一搜</a>，发现 i18n 模型是个自古以来的难题。</p><p>我也找了一些看，包括 <code>rust-i18n</code>, <code>r18</code>, <code>i18n-embed</code>, <code>fluent-rs</code>，最后还是感觉 <code>rust-i18n</code> 文档清晰，模型简单，比较适合我的项目。</p><h2 id="external" tabindex="-1"><a class="header-anchor" href="#external"><span>external</span></a></h2><p>books:</p><ol><li><a href="https://course.rs/about-book.html" target="_blank" rel="noopener noreferrer">Rust 语言圣经</a>：圣经，文风上乘，质量高。</li><li><a href="https://tourofrust.com/00_zh-cn.html" target="_blank" rel="noopener noreferrer">tour of rust</a>：交互授课式，基础入门。</li><li><a href="https://doc.rust-lang.org/rust-by-example/index.html" target="_blank" rel="noopener noreferrer">rust by example</a>：注重例子。</li><li><a href="https://zjp-cn.github.io/tlborm/introduction.html" target="_blank" rel="noopener noreferrer">小宏书</a>：专门介绍 rust macro</li><li><a href="https://marabos.nl/atomics/" target="_blank" rel="noopener noreferrer">Rust Atomics and Locks</a>：底层并发原理入门</li><li><a href="https://rust-book.junmajinlong.com/about.html" target="_blank" rel="noopener noreferrer">Rust 入门秘籍</a>：一本既简洁又深入的书，非常值得一看（特别是 tokio 相关章节）。</li><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%99%88%E5%A4%A9%20%C2%B7%20Rust%20%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%E8%AE%A9Rust%E6%88%90%E4%B8%BA%E4%BD%A0%E7%9A%84%E4%B8%8B%E4%B8%80%E9%97%A8%E4%B8%BB%E5%8A%9B%E8%AF%AD%E8%A8%80.md" target="_blank" rel="noopener noreferrer">Rust 编程第一课 - 陈天</a>：比较进阶的书，写得很好，着重讲述了难点和实战</li><li><a href="https://github.com/alexpusch/rust-magic-patterns" target="_blank" rel="noopener noreferrer">Rust magic patterns</a>：针对某些狭小的知识点的深入分析</li></ol><p>articles:</p><ol><li><a href="https://silente.top/posts/Rust-Learning-Smart-Pointers/" target="_blank" rel="noopener noreferrer">Rust Learning Smart Pointers</a></li><li><a href="https://nihil.cc/posts/rust_closure_and_y/" target="_blank" rel="noopener noreferrer">Rust 中的闭包递归与 Y 组合子</a></li><li>随机 <a href="https://dtolnay.github.io/rust-quiz/" target="_blank" rel="noopener noreferrer">Rust Quiz - dtolnay</a> / <a href="https://boxyuwu.github.io/rust-quiz/" target="_blank" rel="noopener noreferrer">Rust Quiz - boxyuwu</a>：想成为语言律师吗？</li><li><a href="https://zhuanlan.zhihu.com/p/404818051" target="_blank" rel="noopener noreferrer">为什么 Rust 需要 Pin, Unpin ？（中文翻译）</a></li><li><a href="https://zhuanlan.zhihu.com/p/64699643" target="_blank" rel="noopener noreferrer">如何理解 rust 中的 Sync、Send？</a></li><li><a href="https://folyd.com/blog/rust-pin-unpin/" target="_blank" rel="noopener noreferrer">Rust 的 Pin 与 Unpin</a></li><li><a href="https://rustcc.cn/article?id=d3954670-a58a-427d-9c0c-6666051f5cc7" target="_blank" rel="noopener noreferrer">static, const, let 声明变量有什么区别？</a></li><li><a href="https://www.shuttle.rs/blog/2024/04/18/using-traits-generics-rust" target="_blank" rel="noopener noreferrer">An introduction to advanced Rust traits and generics</a></li><li><a href="https://bingowith.me/2021/05/09/translation-async-what-is-blocking/" target="_blank" rel="noopener noreferrer">[翻译] async: 什么是 blocking</a></li><li><a href="https://www.ihcblog.com/rust-runtime-design-1/" target="_blank" rel="noopener noreferrer">Rust Runtime 设计与实现-科普篇</a> 及后续系列文章</li><li><a href="https://lucumr.pocoo.org/2024/5/16/macro-vtable-magic/" target="_blank" rel="noopener noreferrer">Using Rust Macros for Custom VTables</a>：如何创建一个 runtime object</li><li><a href="https://www.youtube.com/live/P7wLTy59-f0" target="_blank" rel="noopener noreferrer">金枪鱼之夜：基于完成的 Rust 异步：compio 项目及其经验</a></li><li><a href="https://zhuanlan.zhihu.com/p/670166312" target="_blank" rel="noopener noreferrer">用 Rust 搞科研的两年</a></li><li><a href="https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/" target="_blank" rel="noopener noreferrer">The missing parts in Cargo</a></li><li><a href="https://matklad.github.io/2021/09/04/fast-rust-builds.html" target="_blank" rel="noopener noreferrer">Fast Rust Builds</a></li><li><a href="https://nihil.cc/posts/phantom_index_type/" target="_blank" rel="noopener noreferrer">幽灵索引类型与匿名结构体</a></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>由于 rust 的 I/O 较为麻烦，leetcode （比起 <em>洛谷</em> 等）能免去 I/O 之苦。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p><a href="https://t.me/QC_Grove/734" target="_blank" rel="noopener noreferrer">https://t.me/QC_Grove/734</a> <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>哪怕同一个编译器同一个包 rust 的编译是有副作用的，比如 env 宏 build script 乃至 proc macro，都是能任意副作用的 (<a href="https://t.me/c/1264662201/550767" target="_blank" rel="noopener noreferrer">ref</a>) <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>为避免傻逼 openssl 造成的影响，建议添加 <code>feature = [&quot;rustls-tls&quot;]</code>。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p><a href="https://t.me/withabsolutex/1441" target="_blank" rel="noopener noreferrer">review 还挺严格的</a>，但是 member 说话又好听 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li></ol></section>`,67);function R(q,T){const r=t("RouteLink"),h=t("ZoomedImg"),p=t("Badge");return o(),k("div",null,[g,u,B,s("ul",null,[b,y,m,f,s("li",null,[a(r,{to:"/gossip/fuckxxx.html#rust-%E6%9C%89%E5%A4%9A%E9%9A%BE%E7%94%A8"},{default:l(()=>[i("我的其他个人暴论")]),_:1})])]),A,s("p",null,[i("然后我使用 "),a(r,{to:"/coding/vscode.html"},{default:l(()=>[i("vscode")]),_:1}),i(" 作为 IDE。安装插件：")]),F,a(h,{alt:"Rust string meme",src:"/images/coding/rust/string_meme.jpg",scale:"80%"}),E,s("ul",null,[v,s("li",null,[C,i(),a(p,{text:"url"}),i(" 是 url 字符串。")])]),_,n(" prettier-ignore "),D,n(" prettier-ignore "),x,n(" prettier-ignore "),w])}const z=d(c,[["render",R],["__file","Rust.html.vue"]]),I=JSON.parse('{"path":"/coding/Rust.html","title":"Rust","lang":"zh-CN","frontmatter":{"date":"2022-05-04T00:00:00.000Z","icon":"brands fa-rust","category":["编程"],"tag":["编程语言"],"description":"Rust 介绍 Rust 是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust 在语法上和 C++类似，但是设计者想要在保证性能的同时提供更好的内存安全。——百度百科 rust 掀起了一股 RIIR (Rewrite it in Rust) 的热潮。 Awesome Alternatives in ...","head":[["meta",{"property":"og:url","content":"https://absx.pages.dev/coding/Rust.html"}],["meta",{"property":"og:site_name","content":"绝对值_x 的博客"}],["meta",{"property":"og:title","content":"Rust"}],["meta",{"property":"og:description","content":"Rust 介绍 Rust 是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust 在语法上和 C++类似，但是设计者想要在保证性能的同时提供更好的内存安全。——百度百科 rust 掀起了一股 RIIR (Rewrite it in Rust) 的热潮。 Awesome Alternatives in ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-01T07:44:58.000Z"}],["meta",{"property":"article:tag","content":"编程语言"}],["meta",{"property":"article:published_time","content":"2022-05-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-01T07:44:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-05-04T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-01T07:44:58.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[{"level":3,"title":"为什么推荐","slug":"为什么推荐","link":"#为什么推荐","children":[]},{"level":3,"title":"如何学习","slug":"如何学习","link":"#如何学习","children":[]}]},{"level":2,"title":"开发环境","slug":"开发环境","link":"#开发环境","children":[{"level":3,"title":"安装 rust","slug":"安装-rust","link":"#安装-rust","children":[]},{"level":3,"title":"开发","slug":"开发","link":"#开发","children":[]}]},{"level":2,"title":"语言基础","slug":"语言基础","link":"#语言基础","children":[{"level":3,"title":"循环","slug":"循环","link":"#循环","children":[]},{"level":3,"title":"输出","slug":"输出","link":"#输出","children":[]},{"level":3,"title":"输入","slug":"输入","link":"#输入","children":[]},{"level":3,"title":"基础数据结构","slug":"基础数据结构","link":"#基础数据结构","children":[]},{"level":3,"title":"container","slug":"container","link":"#container","children":[]},{"level":3,"title":"monad","slug":"monad","link":"#monad","children":[]},{"level":3,"title":"字符串","slug":"字符串","link":"#字符串","children":[]},{"level":3,"title":"语法糖","slug":"语法糖","link":"#语法糖","children":[]},{"level":3,"title":"并发","slug":"并发","link":"#并发","children":[]},{"level":3,"title":"mod","slug":"mod","link":"#mod","children":[]},{"level":3,"title":"trait","slug":"trait","link":"#trait","children":[]},{"level":3,"title":"dyn object","slug":"dyn-object","link":"#dyn-object","children":[]},{"level":3,"title":"宏","slug":"宏","link":"#宏","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"Cargo","slug":"cargo","link":"#cargo","children":[{"level":3,"title":"cargo envs","slug":"cargo-envs","link":"#cargo-envs","children":[]},{"level":3,"title":"全局 alias","slug":"全局-alias","link":"#全局-alias","children":[]},{"level":3,"title":"fmt","slug":"fmt","link":"#fmt","children":[]},{"level":3,"title":"构建","slug":"构建","link":"#构建","children":[]},{"level":3,"title":"扩展","slug":"扩展","link":"#扩展","children":[]}]},{"level":2,"title":"库","slug":"库","link":"#库","children":[{"level":3,"title":"clap","slug":"clap","link":"#clap","children":[]},{"level":3,"title":"once_cell","slug":"once-cell","link":"#once-cell","children":[]},{"level":3,"title":"thiserror","slug":"thiserror","link":"#thiserror","children":[]},{"level":3,"title":"serde","slug":"serde","link":"#serde","children":[]}]},{"level":2,"title":"打包","slug":"打包","link":"#打包","children":[{"level":3,"title":"最小化二进制","slug":"最小化二进制","link":"#最小化二进制","children":[]},{"level":3,"title":"交叉编译","slug":"交叉编译","link":"#交叉编译","children":[]},{"level":3,"title":"release","slug":"release","link":"#release","children":[]}]},{"level":2,"title":"发布","slug":"发布","link":"#发布","children":[]},{"level":2,"title":"测试","slug":"测试","link":"#测试","children":[{"level":3,"title":"cargo bench","slug":"cargo-bench","link":"#cargo-bench","children":[]}]},{"level":2,"title":"用户界面","slug":"用户界面","link":"#用户界面","children":[{"level":3,"title":"GUI","slug":"gui","link":"#gui","children":[]},{"level":3,"title":"TUI","slug":"tui","link":"#tui","children":[]}]},{"level":2,"title":"嵌入向量数据库","slug":"嵌入向量数据库","link":"#嵌入向量数据库","children":[]},{"level":2,"title":"r18n","slug":"r18n","link":"#r18n","children":[]},{"level":2,"title":"external","slug":"external","link":"#external","children":[]}],"git":{"createdTime":1651638772000,"updatedTime":1738395898000,"contributors":[{"name":"lxl66566","email":"lxl66566@gmail.com","commits":71},{"name":"lxl66566","email":"18259734087@163.com","commits":17}]},"readingTime":{"minutes":21.66,"words":6499},"filePathRelative":"coding/Rust.md","localizedDate":"2022年5月4日","excerpt":"\\n","autoDesc":true}');export{z as comp,I as data};
