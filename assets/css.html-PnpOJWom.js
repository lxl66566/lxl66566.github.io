import{_ as e,o as t,c as a,e as o}from"./app-BzilSif_.js";const r={},l=o('<h1 id="css" tabindex="-1"><a class="header-anchor" href="#css"><span>CSS</span></a></h1><p>本人是 CSS 超级苦手，甚至以前都只会写 nocss 页面。但是如果要给别人做东西用，nocss 肯定不太行。当今所有主流 GUI 框架中没一个打得过前端设计，我也想在前端领域玩玩，因此学习一点 CSS 是有必要的。</p><h2 id="预处理器" tabindex="-1"><a class="header-anchor" href="#预处理器"><span>预处理器</span></a></h2><p>css 本身不带逻辑，处理嵌套也麻烦。因此有各种各样的预处理器可以允许我们写更强大、更有意思的扩展语法，然后由它们在编译器改成标准 css。</p><ul><li>scss：sass 3.0 的别名，我觉得最泛用的。</li><li><a href="https://lesscss.org/" target="_blank" rel="noopener noreferrer">less</a>，朋友的公司在用</li></ul><p>上面两个预处理器都兼容原生 css。</p><h2 id="框架" tabindex="-1"><a class="header-anchor" href="#框架"><span>框架</span></a></h2><p>虽说写原生 CSS 也不是不行，但是有框架为什么不用呢。</p><p>大多数框架都喜欢将 “写 css” 变为 “写 class”，免去了 html 和 css 之间切来切去的烦恼，用得熟练的话确实可以加快开发速度。对于初学者来说就是多了查文档的时间，如果文档烂的话还是挺烦人的。</p><ul><li><a href="https://unocss.dev/" target="_blank" rel="noopener noreferrer">UnoCSS</a>：新一代完全自定义化的 css 框架。</li><li><a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">tailwindcss</a>：一套预设的 class。目前广泛使用。</li><li>Bootstrap：老一辈预设的 class，目前算是被 tailwindcss 取代了吧(?)</li></ul><h2 id="盒模型" tabindex="-1"><a class="header-anchor" href="#盒模型"><span>盒模型</span></a></h2><p>前端基础概念了。</p><ul><li>标准盒模型：<code>box-sizing: content-box</code>，content = size；border 和 padding 向外扩展</li><li>IE 盒模型：<code>box-sizing: border-box</code>，content = size - border - padding，可以从外部统一大小。</li></ul><div style="position:relative;width:400px;"><!-- Margin Layer --><div style="background-color:#e8f4f8;padding:20px;text-align:center;border:2px dashed #a8d1dc;"><div style="position:absolute;top:0px;left:50%;transform:translateX(-50%);background-color:white;padding:2px 8px;border-radius:4px;font-size:14px;"> margin </div><!-- Border Layer --><div style="background-color:#ffb6b6;padding:20px;"><div style="position:absolute;top:20px;left:50%;transform:translateX(-50%);background-color:white;padding:2px 8px;border-radius:4px;font-size:14px;"> border </div><!-- Padding Layer --><div style="background-color:#e6ffe6;padding:20px;"><div style="position:absolute;top:40px;left:50%;transform:translateX(-50%);background-color:white;padding:2px 8px;border-radius:4px;font-size:14px;"> padding </div><!-- Content Layer --><div style="background-color:#fff2e6;padding:20px;text-align:center;">Content Area</div></div></div></div></div><h2 id="flex-布局" tabindex="-1"><a class="header-anchor" href="#flex-布局"><span>flex 布局</span></a></h2><p>flex 布局是响应式的绝佳实践，而且对于前端初学者来说，flex 也非常符合界面直觉。</p><p>关于版本：flex <a href="https://www.cnblogs.com/xiaohuochai/p/5323146.html" target="_blank" rel="noopener noreferrer">有多个版本</a>。2024 年了，不需要考虑 flex 兼容性，可以假定所有浏览器都支持最新版本 flex。</p><p>无脑 flex：想要让内部的玩意水平垂直居中，可以直接无脑 flex：<code>display: flex; align-items: center; justify-content: center;</code></p><p>flex 基础：</p><ol><li>主轴与交叉轴：主轴是元素排布的方向，交叉轴是与主轴垂直的方向。</li><li>basis, <a href="https://juejin.cn/post/6844904016439148551" target="_blank" rel="noopener noreferrer">grow and shrink</a><ul><li>basis 是每个元素的基础长度。默认为 0，此时使用元素 width （或 height）。</li><li>grow 是当所有元素填不满 flex 时，对于剩下的空间的瓜分策略。实际上就是按 grow 比例瓜分。</li><li>shrink 是当所有元素超出 flex 时，对所有元素的压缩策略。每个元素被压缩的空间也是按 shrink 比例压缩。</li></ul></li><li>对齐： <ul><li>主轴：<code>justify-content</code>。一般常用的有 <code>center</code>, <code>space-between</code>, <code>space-around</code>, <code>space-evenly</code></li><li>交叉轴：一旦使用了 flex，所有元素就会在交叉轴上被拉到最大（由默认值 <code>align-items: stretch;</code> 控制），非常直觉。</li></ul></li><li>超出自动换行：<code>flex-wrap: wrap;</code>；换行后又会引入行间对齐 <code>align-content</code>。</li></ol><h2 id="external" tabindex="-1"><a class="header-anchor" href="#external"><span>external</span></a></h2><ol><li><a href="https://zh.learnlayout.com/" target="_blank" rel="noopener noreferrer">学习 CSS 布局</a></li></ol>',22),n=[l];function i(s,c){return t(),a("div",null,n)}const p=e(r,[["render",i],["__file","css.html.vue"]]),h=JSON.parse('{"path":"/coding/css.html","title":"CSS","lang":"zh-CN","frontmatter":{"date":"2024-12-13T00:00:00.000Z","icon":"brands fa-css","category":["编程"],"tag":["前端"],"description":"CSS 本人是 CSS 超级苦手，甚至以前都只会写 nocss 页面。但是如果要给别人做东西用，nocss 肯定不太行。当今所有主流 GUI 框架中没一个打得过前端设计，我也想在前端领域玩玩，因此学习一点 CSS 是有必要的。 预处理器 css 本身不带逻辑，处理嵌套也麻烦。因此有各种各样的预处理器可以允许我们写更强大、更有意思的扩展语法，然后由它们在...","head":[["meta",{"property":"og:url","content":"https://absx.pages.dev/coding/css.html"}],["meta",{"property":"og:site_name","content":"绝对值_x的博客"}],["meta",{"property":"og:title","content":"CSS"}],["meta",{"property":"og:description","content":"CSS 本人是 CSS 超级苦手，甚至以前都只会写 nocss 页面。但是如果要给别人做东西用，nocss 肯定不太行。当今所有主流 GUI 框架中没一个打得过前端设计，我也想在前端领域玩玩，因此学习一点 CSS 是有必要的。 预处理器 css 本身不带逻辑，处理嵌套也麻烦。因此有各种各样的预处理器可以允许我们写更强大、更有意思的扩展语法，然后由它们在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-18T11:17:41.000Z"}],["meta",{"property":"article:tag","content":"前端"}],["meta",{"property":"article:published_time","content":"2024-12-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-18T11:17:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CSS\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-13T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-18T11:17:41.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"预处理器","slug":"预处理器","link":"#预处理器","children":[]},{"level":2,"title":"框架","slug":"框架","link":"#框架","children":[]},{"level":2,"title":"盒模型","slug":"盒模型","link":"#盒模型","children":[]},{"level":2,"title":"flex 布局","slug":"flex-布局","link":"#flex-布局","children":[]},{"level":2,"title":"external","slug":"external","link":"#external","children":[]}],"git":{"createdTime":1734082658000,"updatedTime":1734520661000,"contributors":[{"name":"lxl66566","email":"lxl66566@gmail.com","commits":2}]},"readingTime":{"minutes":2.87,"words":862},"filePathRelative":"coding/css.md","localizedDate":"2024年12月13日","excerpt":"\\n","autoDesc":true}');export{p as comp,h as data};
