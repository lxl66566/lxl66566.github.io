import{_ as r,e as p,f as t,g as s,h as a,i as n,j as l,r as h,o}from"./app-DF9b76ZI.js";const d={},k={class:"footnotes"},g={class:"footnotes-list"},u={id:"footnote2",class:"footnote-item"};function c(f,i){const e=h("RouteLink");return o(),p("div",null,[i[18]||(i[18]=t('<h1 id="编程语言哲学胡言乱语" tabindex="-1"><a class="header-anchor" href="#编程语言哲学胡言乱语"><span>编程语言<s>哲学</s>胡言乱语</span></a></h1><blockquote><p>在编程领域我只是一个 beginner，读书不够多，此处是一点<strong>不成熟的拙见</strong>，甚至<strong>漏洞百出</strong>，请读者阅读时<strong>抱有质疑</strong>，同时欢迎批评指正。</p></blockquote><p>在接触了各种编程语言后，我常常思考如何构建自己的编程语言，这也是我了解、尝试各种语言的动力之一。</p><p>编程语言是建立在抽象上的。从机器码到指令集，从汇编到高阶语言，从编译型到解释型，语言在抽象的同时也带来了巨大的开销。</p><p>解耦是编程语言中重要的一环。后文有着更深入的描述。</p>',5)),s("p",null,[i[1]||(i[1]=a("从编程语言哲学衍生出的抽象与解耦的概念，也是形成")),n(e,{to:"/gossip/va_view.html"},{default:l(()=>i[0]||(i[0]=[a("我的价值观")])),_:1}),i[2]||(i[2]=a("的重要因素之一。我将抽象与解耦的 ")),i[3]||(i[3]=s("em",null,"现实举例",-1)),i[4]||(i[4]=a(" 放在了价值观页面，有兴趣可以跳转查看。"))]),i[19]||(i[19]=t(`<h2 id="狭义-抽象" tabindex="-1"><a class="header-anchor" href="#狭义-抽象"><span>（狭义）抽象</span></a></h2><p>我们将每一条指令、一个数据看作一个点。</p><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h3><p>我愿意说函数是最早的抽象。<em>函数</em> 这个概念比 <em>编程</em> 出现还早得多，因此说底层也不足怪。现代处理器的指令集本身就可以看成是电路操作的函数。</p><p>很容易把函数想象成 pipe，一边输入，一边输出，因此函数是线级抽象。（真的吗？）</p><ul><li>Question: 假设 RISC 是 CISC 的解耦，那么 CISC 指令集是否还是函数层级抽象？</li></ul><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><p>我原先认为结构是比函数高一阶的抽象（并且也这么写了），但事实上，如果说函数是指令的集合，结构是数据的集合，那么它们的阶数理应是相同的。如果函数与 OOP 的阶数差为 2，那么后文中的一些地方很难解释得通。因此先暂且（不严谨地）认为，结构和函数是同一级抽象。</p><p>C 的 struct &amp; union 可以组合任意数据类型。由于 <code>void*</code> 的存在，什么 function pointer 啦都可以往 struct 里塞。</p><p>等等，这对吗？组合内可以有函数，函数的参数可以是组合，这其中的维度关系相当混乱。现在暂且把它当成抽象大厦上的一朵乌云~</p><h3 id="oop" tabindex="-1"><a class="header-anchor" href="#oop"><span>OOP</span></a></h3><p>最后才是 OOP 的天下。OOP 是比组合高阶的抽象（面级），优化了函数的组合语法，加了权限控制，继承关系等。其中的<strong>继承关系</strong>是关键，是抽象进阶的根源。</p><p>所有类（包括抽象类）如果是单继承的，那么继承关系构成一颗（许多棵）树。</p><h4 id="interface-trait" tabindex="-1"><a class="header-anchor" href="#interface-trait"><span>interface &amp; trait</span></a></h4><p>至于 interface 和 trait 就更复杂了，我一开始还不太清楚它们的抽象层级。它们看起来花里胡哨，把自己叫成 implement<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup> 而不是 inherit，实际上也可以直接看成多继承特性，交织的继承关系不再是树而是 DAG，但仍然没有维度上的突破。</p><p>相比之下，trait 要比 interface 灵活一点。</p><ul><li>interface 不提供方法实现，充其量只能算是多继承 dlc 而已。trait 则是拿着不同具体实现往 struct/dyn trait 上贴，</li><li>java 说 <code>(a class) implementing an interface</code>，是以 class 为主导的。而 rust 说 <code>impl(ement) trait for a struct</code>，以 trait 为主导。这种差异也导致我写 java 会先脑测好 interface，再用 class 去 implement，而写 rust 就刷刷刷，突然有想法就一拍脑袋拍出一个 trait 用。</li></ul><p>很难想象 interface 和 trait 是同一个抽象层次的东西，但它们确实是。</p><h3 id="指针" tabindex="-1"><a class="header-anchor" href="#指针"><span>指针</span></a></h3><p>指针是构成现代计算机的基础。由于指针没有权限控制，很容易写出不安全的代码，也徒增了许多心智负担。因此现代的语言都试图弱化指针在编程语言中的地位，将其抽象成什么别的东西。</p><p>C++ 的引用原先是指针的语法糖，后来添加了右值引用，事实上就是所有权的控制。</p><p>Java, JS, Python 等语言直接将指针的概念剥离了出去，使用较为简单粗暴的方式：基本类型都是传值，对象类型（包括其他复杂类型）都是传引用（指针）。</p><p>Rust 用引用的概念来代替指针，不过也保留了 unsafe 中的指针操作。要注意的是 C++ 的引用概念应该相当于 Rust 的 Box，而不是引用（ans：引用的引用？）。</p><h3 id="monad" tabindex="-1"><a class="header-anchor" href="#monad"><span>monad</span></a></h3><p>monad 是在函数式中的一个概念，可以理解成一种“包装”。Rust 中的 Option, Result 都是 monad。</p><p>有一些语言不喜欢 monad 的抽象。最容易看出来的就是用函数接受 default 参数的语言：</p><ul><li>python 的 getattr：<div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> getattr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">    o</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> object</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">    name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">    default</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> None</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    /</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; (Any </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> None</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">): </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>typst<div class="language-typst line-numbers-mode" data-highlighter="shiki" data-ext="typst" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> values</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">#values.at(6, default: values.at(-1))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>这样就会出现诸如<a href="https://github.com/typst/typst/issues/3052" target="_blank" rel="noopener noreferrer">求值顺序</a>，多层嵌套难看等各种问题。而一个好的解法是将返回值抽象为 monad，例如 rust：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> xxx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Option</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>Option</code> 是一个 monad 抽象，其代表了“可能有值”。然后，再从 monad 中取出内部值：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> xxx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unwrap_or_else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>取值部分，可以设 default，可以立刻求值，可以懒求值，可以方便地嵌套，具有非常高的灵活性。</p><h2 id="组合" tabindex="-1"><a class="header-anchor" href="#组合"><span>组合</span></a></h2><p>常有人说，组合优于继承。一个现实的例子是，rust struct 无法继承，只能组合。</p><p>组合究竟是不是抽象的一个子类，我还没有搞清楚，这里先写着。</p><ul><li>Question: 网上有一些说法认为 <a href="#interface--trait">interface &amp; trait</a> 属于组合。这种说法有没有道理？</li></ul><h3 id="fp" tabindex="-1"><a class="header-anchor" href="#fp"><span>FP</span></a></h3><p>现在还有很多函数式（<em>Functional Programming</em>）语言流行并活跃，比如 Ocaml, Haskell, Lisp, 还有新的 koka。FP 通过组合，得到高阶函数，完成复用。</p><p>FP 的基础是 lambda 演算，组合子<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>等。我自己也没有系统地学习过 FP，这里就不献丑了。</p><h2 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理"><span>错误处理</span></a></h2><p>目前编程语言的错误处理主要有两类，throw/catch 模型和 Result 模型。老牌语言更多使用前者，新兴语言更多使用后者。</p><p>throw/catch 看着非常像硬件中断。硬件中断会起一个错误处理线程来解决中断，并在解决后恢复（可恢复中断）。而 throw 的过程可以比作开启线程，catch 就是线程可执行部分。</p><p>理论上 throw/catch 应该算是普通的抽象。</p><p>Result 不是新兴语言的专利，C 语言的状态码也是 Result。非常明显，Result 是组合的那一类。</p><ul><li>共同点：都有“是否可能抛出异常”的区别。</li></ul><h2 id="并发" tabindex="-1"><a class="header-anchor" href="#并发"><span>并发</span></a></h2><p>目前大多数语言的并发基本都被 async/await 模型统一了。剩下 go 这种有栈协程还在支持。</p><p>async/await 模型是接近 FP 的体现，相当于把程序在 await 点切割，由一个/多个调度器控制程序调度。</p><h2 id="解耦" tabindex="-1"><a class="header-anchor" href="#解耦"><span>解耦</span></a></h2>`,49)),s("p",null,[i[6]||(i[6]=a("（相关条目：")),n(e,{to:"/gossip/va_view.html#%E8%A7%A3%E8%80%A6%E8%AE%BA"},{default:l(()=>i[5]||(i[5]=[a("杂论 - 解耦论")])),_:1}),i[7]||(i[7]=a("）"))]),i[20]||(i[20]=t('<p>已经有部分语言开始自发地（或被迫地）解耦。</p><ul><li><p><a href="#external">external 3.</a> 介绍了 JavaScript 普通函数和异步函数的解耦。</p></li><li><p><a href="#external">external 4.</a> 构想了数据类型和模块的解耦。</p></li><li><p>Question: Trait 剥离了 OOP 的 inheritance，算不算一种解耦？</p></li></ul><h3 id="module" tabindex="-1"><a class="header-anchor" href="#module"><span>module</span></a></h3><p>模块化是很好的解耦实例。模块化把抽象出的结构包成黑箱，只留下外部 API 接口，能够方便代码复用，减轻程序员心智负担。</p><p>模块化的另一个关键是组合（FP 不请自来）。将小模块组合成大模块，提供更高层次的抽象。</p><p>例如 OOP 很好地实现了模块化的思想（权限控制）。</p><h4 id="语言实现" tabindex="-1"><a class="header-anchor" href="#语言实现"><span>语言实现</span></a></h4>',7)),s("ul",null,[i[11]||(i[11]=s("li",null,"C 这种底层语言没有模块化。可以理解。",-1)),i[12]||(i[12]=s("li",null,[a("C++ 的模块化做的稀烂，"),s("code",null,"#include"),a(" 只是简单地复制代码。之前一般用 "),s("code",null,"inline"),a(" 内联，C++ 20 以后才有了 module，但直到现在各方编译器的实现还不完善。")],-1)),s("li",null,[i[9]||(i[9]=a("python 的模块")),n(e,{to:"/gossip/fuckxxx.html#python-%E6%9C%89%E5%A4%9A%E9%9A%BE%E7%94%A8"},{default:l(()=>i[8]||(i[8]=[a("粒度不够细")])),_:1}),i[10]||(i[10]=a("，无法实现交叉引用，本质只是复制代码（加强版）而已(?)。"))])]),i[21]||(i[21]=t('<h2 id="特化" tabindex="-1"><a class="header-anchor" href="#特化"><span>特化</span></a></h2><p>特化（specialization）是在面对多个泛型匹配项时，编译器根据内置优先级规则进行选择的行为。C++ 模板以复杂的特化闻名，甚至 Rust 也<a href="https://github.com/rust-lang/rust/issues/31844" target="_blank" rel="noopener noreferrer">走上了特化的道路</a>（min_specialization）。</p><p>但是我非常不喜欢特化，它极大增加了语言的复杂性，给人脑造成了不小的记忆负担。我倾向于类型集合论，如果类型系统是集合论完备的，并且规定同一个对象的所有泛型不允许交叉，那就不会出现特化的问题，匹配项可以由程序员决定。</p><h2 id="细分" tabindex="-1"><a class="header-anchor" href="#细分"><span>细分</span></a></h2><p>优先级，未完待续</p><h2 id="梦中情语" tabindex="-1"><a class="header-anchor" href="#梦中情语"><span>梦中情语</span></a></h2><p>on <a href="https://github.com/lxl66566/DreamScript" target="_blank" rel="noopener noreferrer">github (WIP)</a></p><h2 id="external" tabindex="-1"><a class="header-anchor" href="#external"><span>external</span></a></h2><ol><li><a href="https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang" target="_blank" rel="noopener noreferrer">Lies we tell ourselves to keep using Golang</a></li><li><a href="https://yorickpeterse.com/articles/a-decade-of-developing-a-programming-language/" target="_blank" rel="noopener noreferrer">A decade of developing a programming language</a></li><li><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener noreferrer">What Color is Your Function?</a></li><li><a href="https://www.youtube.com/watch?v=0iyB0_qPvWk" target="_blank" rel="noopener noreferrer">Object-Oriented Programming is Good*</a></li><li><a href="https://without.boats/blog/coroutines-and-effects/" target="_blank" rel="noopener noreferrer">Coroutines and effects</a></li></ol><hr class="footnotes-sep">',10)),s("section",k,[s("ol",g,[i[17]||(i[17]=s("li",{id:"footnote1",class:"footnote-item"},[s("p",null,[a('implement 有一种在《三体》"蓝色空间"号上通过四维空间碎片（高阶抽象）支配三维空间（低阶抽象）的感觉。 '),s("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎")])],-1)),s("li",u,[s("p",null,[i[14]||(i[14]=a("有一篇可以拿来当组合子快速入门的文章在 ")),n(e,{to:"/coding/Rust.html#external"},{default:l(()=>i[13]||(i[13]=[a("rust external 2.")])),_:1}),i[15]||(i[15]=a("。 ")),i[16]||(i[16]=s("a",{href:"#footnote-ref2",class:"footnote-backref"},"↩︎",-1))])])])])])}const y=r(d,[["render",c],["__file","philosophy_of_PL.html.vue"]]),A=JSON.parse('{"path":"/coding/philosophy_of_PL.html","title":"编程语言哲学胡言乱语","lang":"zh-CN","frontmatter":{"date":"2023-12-17T00:00:00.000Z","icon":"question","category":["编程","主张"],"tag":["编程语言","哲学"],"description":"编程语言胡言乱语 在编程领域我只是一个 beginner，读书不够多，此处是一点不成熟的拙见，甚至漏洞百出，请读者阅读时抱有质疑，同时欢迎批评指正。 在接触了各种编程语言后，我常常思考如何构建自己的编程语言，这也是我了解、尝试各种语言的动力之一。 编程语言是建立在抽象上的。从机器码到指令集，从汇编到高阶语言，从编译型到解释型，语言在抽象的同时也带来了巨...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编程语言哲学胡言乱语\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-19T15:10:44.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://absx.pages.dev/coding/philosophy_of_PL.html"}],["meta",{"property":"og:site_name","content":"绝对值_x 的博客"}],["meta",{"property":"og:title","content":"编程语言哲学胡言乱语"}],["meta",{"property":"og:description","content":"编程语言胡言乱语 在编程领域我只是一个 beginner，读书不够多，此处是一点不成熟的拙见，甚至漏洞百出，请读者阅读时抱有质疑，同时欢迎批评指正。 在接触了各种编程语言后，我常常思考如何构建自己的编程语言，这也是我了解、尝试各种语言的动力之一。 编程语言是建立在抽象上的。从机器码到指令集，从汇编到高阶语言，从编译型到解释型，语言在抽象的同时也带来了巨..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:10:44.000Z"}],["meta",{"property":"article:tag","content":"哲学"}],["meta",{"property":"article:tag","content":"编程语言"}],["meta",{"property":"article:published_time","content":"2023-12-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:10:44.000Z"}]]},"git":{"createdTime":1702829650000,"updatedTime":1760886644000,"contributors":[{"name":"lxl66566","username":"lxl66566","email":"lxl66566@gmail.com","commits":10,"url":"https://github.com/lxl66566"}]},"readingTime":{"minutes":7.89,"words":2368},"filePathRelative":"coding/philosophy_of_PL.md","localizedDate":"2023年12月17日","excerpt":"\\n","autoDesc":true}');export{y as comp,A as data};
