import{_ as o,e as d,g as s,k as h,f as a,h as i,i as t,j as p,r as n,o as c}from"./app-a0zJsalQ.js";const k={},g={class:"hint-container details"};function m(u,e){const r=n("Badge"),l=n("RouteLink");return c(),d("div",null,[e[13]||(e[13]=s("h1",{id:"基础",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#基础"},[s("span",null,"基础")])],-1)),s("ol",null,[e[4]||(e[4]=a('<li>我建议仔细看看 <a href="https://missing-semester-cn.github.io/" target="_blank" rel="noopener noreferrer">The Missing</a>的前几章，比较到位，<strong>免去了自己折腾之苦</strong>（本人亲身体会）。</li><li><a href="https://zhuanlan.zhihu.com/p/495554731" target="_blank" rel="noopener noreferrer">Linux ls -al 得到的结果代表什么意思？</a></li><li><code>[Y/n]</code> 可以直接回车表示确认。<code>Y</code> 大写表示默认。(<a href="https://t.me/archlinuxcn_group/2950979" target="_blank" rel="noopener noreferrer">ref</a>)</li><li>awk 是一门（图灵完备的）语言(<a href="https://luoxu.archlinuxcn.org/#g=1031857103&amp;q=awk+%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener noreferrer">ref</a>)，<s>但我从不用 awk</s>。</li>',4)),s("li",null,[e[0]||(e[0]=i("linux 可执行文件没有后缀；可以用 ")),e[1]||(e[1]=s("code",null,"detect-it-easy-bin",-1)),e[2]||(e[2]=i()),t(r,{text:"AUR"}),e[3]||(e[3]=i(" 查看任意文件的类型。"))])]),e[14]||(e[14]=s("h2",{id:"terminal-shortcuts",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#terminal-shortcuts"},[s("span",null,"Terminal shortcuts")])],-1)),e[15]||(e[15]=s("p",null,[s("code",null,"<C-a>"),i(" 代表 "),s("code",null,"Ctrl + a"),i(".")],-1)),h(" prettier-ignore "),e[16]||(e[16]=a('<table><thead><tr><th style="text-align:center;">按键</th><th style="text-align:center;">执行</th></tr></thead><tbody><tr><td style="text-align:center;"><code>&lt;C-a&gt;</code></td><td style="text-align:center;">移动光标到最前</td></tr><tr><td style="text-align:center;"><code>&lt;C-LEFT&gt;</code> &amp; <code>&lt;C-LEFT&gt;</code></td><td style="text-align:center;">移动光标到上 / 下一个单词</td></tr><tr><td style="text-align:center;"><code>&lt;C-w&gt;</code></td><td style="text-align:center;">删除前一个单词</td></tr><tr><td style="text-align:center;"><code>&lt;C-u&gt;</code></td><td style="text-align:center;">清空光标前输入</td></tr></tbody></table><p>您还可以查看<a href="https://effective-shell.com/part-2-core-skills/fly-on-the-command-line" target="_blank" rel="noopener noreferrer">本文</a>获取更多实用 shortcuts。</p><h2 id="posix-指令" tabindex="-1"><a class="header-anchor" href="#posix-指令"><span>POSIX 指令</span></a></h2><blockquote><p>不是系统性描述，更多是一些 tricks 和踩坑；可能不是最简，欢迎指正。</p></blockquote><h3 id="sed" tabindex="-1"><a class="header-anchor" href="#sed"><span>sed</span></a></h3><ul><li>sed 正则表达式的 <code>{}</code> 需要转义 <code>\\{\\}</code>，否则需要使用 <code>sed -r</code>（maybe <code>alias sed=&#39;sed -r&#39;</code> ?）</li><li>冷知识：sed（和 awk）都是图灵完备的语言。</li></ul><h3 id="grep" tabindex="-1"><a class="header-anchor" href="#grep"><span>grep</span></a></h3><ul><li>grep 不支持贪婪匹配 <code>.*?</code>，需要的话要 <code>grep -P</code> (<code>--perl-regexp</code>)</li></ul><h3 id="find" tabindex="-1"><a class="header-anchor" href="#find"><span>find</span></a></h3><ul><li>末尾的 <code>\\;</code> 的作用是声明了 <code>-exec</code> 的结尾。</li><li>众所周知如果要删除当前目录中的所有文件，排除目录，可以直接 <code>rm *</code>。若我要反过来，只删除目录而排除文件呢？<div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">find</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> .</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -maxdepth</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -mindepth</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -exec</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rm</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -r</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> {}</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># OR `find . -maxdepth 1 -mindepth 1 -type d -print0 | xargs -0 rm -r`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>复制目录下所有文件，除了其中一个：<div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">find</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> .</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -maxdepth</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -mindepth</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> !</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;exclude.*&#39;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> f</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -exec</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cp</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> {}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> to_dir</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><p>通过这些例子，应该就能基本上手 <code>find</code> 了。</p><h3 id="xargs" tabindex="-1"><a class="header-anchor" href="#xargs"><span>xargs</span></a></h3><p>将管道前的值传入后面的语句的<strong>最后方</strong>。</p><h3 id="sudo" tabindex="-1"><a class="header-anchor" href="#sudo"><span>sudo</span></a></h3><ul><li><code>sudo nvim</code> 相当于切换到 root 用户空间，无法使用用户 nvim 配置。然而 <code>sudo -e</code> 编辑文件，相当于在用户空间编辑完后覆盖回去，是可以用用户配置的。</li></ul><h2 id="文件系统-fs" tabindex="-1"><a class="header-anchor" href="#文件系统-fs"><span>文件系统(fs)</span></a></h2><blockquote><p>事实上文件系统的内容非常之大，这里主要还是偏向磁盘文件系统的应用方向的。</p></blockquote><p>ext4 是许多 linux 的默认 fs，有的 archlinux 教程也使用 ext4，我使用 btrfs，除此之外常用的文件系统还有 zfs, xfs, bcachefs 等。这里着重讲 btrfs。（其他的我都没用过啊</p><blockquote><p><a href="https://t.me/archlinuxcn_group/2949935" target="_blank" rel="noopener noreferrer">有前辈说</a>了一些 zfs 的优势。 xfs 比较适合数据库使用，并发写性能好 (<a href="https://t.me/archlinuxcn_group/2963733" target="_blank" rel="noopener noreferrer">ref</a>)</p></blockquote><h3 id="btrfs" tabindex="-1"><a class="header-anchor" href="#btrfs"><span>btrfs</span></a></h3><p>对于一个用惯 windows ntfs 的人来说，btrfs <span class="heimu" title="你知道的太多了">as well as 现代文件系统</span>一定能让他眼前一亮。（文章参考 <a href="#external">external</a> 1.）</p><ol><li>CoW(写时复制)</li><li>透明压缩</li><li>快照</li><li>只有 btrfs 能 online shrink (<a href="https://t.me/archlinuxcn_group/2996595" target="_blank" rel="noopener noreferrer">ref</a>)</li></ol><p>目前 btrfs 比起其他现代文件系统，缺的只是 raid5/6 支持和加密；但是其使用难度比很多其他 fs 低多了。</p><p>使用 btrfs 有一些坑需要注意：</p><ol><li>由于 CoW，使用 <code>du</code> 查看磁盘空间可能不准确，需要使用：<code>btrfs fi usage /</code>.</li><li>由于 CoW + 快照，操作数据库的时候需要小心，尽可能不要将数据库加入快照备份区（可以使用其他子卷存放）。</li></ol><h4 id="常用指令" tabindex="-1"><a class="header-anchor" href="#常用指令"><span>常用指令</span></a></h4><ul><li><code>btrfs fi us /</code>：查看已用大小</li><li><code>sudo btrfs scrub start /</code> &amp;&amp; <code>btrfs scrub status /</code>：检查 checksum</li></ul><h4 id="工具" tabindex="-1"><a class="header-anchor" href="#工具"><span>工具</span></a></h4><p><a href="https://github.com/knorrie/btrfs-heatmap" target="_blank" rel="noopener noreferrer">btrfs-heatmap</a> 可以看 bg 的大小与碎片分布 (<a href="https://blog.lilydjwg.me/2023/7/25/btrfs-metadata-full.216670.html" target="_blank" rel="noopener noreferrer">src</a>)。</p><h4 id="互操作" tabindex="-1"><a class="header-anchor" href="#互操作"><span>互操作</span></a></h4><p>互操作能极大提升多系统使用体验。<span class="heimu" title="你知道的太多了">ext4 从 windows 访问根本没啥好用工具</span></p><p>众所周知 windows 默认使用它那 ntfs 已经很久了，并且默认没有 btrfs 支持。而双系统经常需要进行文件的互访问。linux 默认可读 ntfs，写入则只需安装 <code>ntfs-3g</code> 即可。而 windows 访问 btrfs 也非常简单。</p><ol><li><a href="https://github.com/maharmstone/btrfs" target="_blank" rel="noopener noreferrer">安装 Winbtrfs</a></li><li>此时已经可以在资源管理器中访问了。</li><li>默认挂载是读写的，我比较建议改为只读，降低出现问题的概率。<a href="https://github.com/maharmstone/btrfs#mount-options" target="_blank" rel="noopener noreferrer">在这里</a>可以进行一些设置，重启生效。</li></ol><p>事实上，<em>winbtrfs</em> 与 <em>ntfs-3g</em> 都不能保证一定不会出问题（有一些群友被坑过）。所以建议都只读不写。</p><p>还有，windows 蓝屏可能会炸硬盘，导致 windows 能读，linux 挂不上。ntfs 炸了就无脑用 chkdsk 修就行。</p><h3 id="链接" tabindex="-1"><a class="header-anchor" href="#链接"><span>链接</span></a></h3><p>分为硬链接和软链接。硬链接文件共享相同的 inode 值，指向同一份文件，因此是同步更新。软链接就是快捷方式。</p><blockquote><p>软链接和快捷方式本质是相同的，但还有一些细微的差别，比如 lnk 还会存 description, icon...</p></blockquote><p>git 内添加链接指向的文件需要手动 <code>git add -f</code>。</p><h3 id="调整大小" tabindex="-1"><a class="header-anchor" href="#调整大小"><span>调整大小</span></a></h3><p>我们日常使用中可能会遇到需要调整分区大小的情况。实际上我们的意思一般是“调整分区和其上的 fs 大小，并保持调整后它们的大小仍然相等”。由于 fs 在分区上层，一般来说，我们需要：</p><ul><li>扩大容量：先扩大分区，再扩大 fs</li><li>缩小容量：先缩小 fs，再缩小分区</li></ul><p>否则会发生数据丢失。</p><p>还有一个注意点是分区的对齐。由于 fs 的元数据（superblock）一般在分区最前面，缩小 fs 和分区默认都是从后方缩小，可能缩小腾出的空间并没有办法给前方分区使用。</p><p>对于 btrfs，我们可以很方便地在线调整 fs 大小，无需使用启动盘 mount。搜索 <code>btrfs fi resize</code> 获取教程。调整大小前建议先清理一下快照，跑一次 balance。</p><h2 id="混成器" tabindex="-1"><a class="header-anchor" href="#混成器"><span>混成器</span></a></h2><p>混成器是向实际屏幕绘制的抽象层，提供了接口供 UI 软件调用。更多混成器相关知识可以看 farseerfc 的两篇博文(<a href="https://farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html" target="_blank" rel="noopener noreferrer">1</a> <a href="https://farseerfc.me/zhs/compositor-in-X-and-compositext.html" target="_blank" rel="noopener noreferrer">2</a>)。</p><p>目前广泛使用的 linux 混成器有 X11 和 Wayland，其中 X11 已宣布停止维护。</p><h3 id="为什么我不使用-wayland" tabindex="-1"><a class="header-anchor" href="#为什么我不使用-wayland"><span>为什么我不使用 Wayland？</span></a></h3><p>现在谈到混成器，Wayland 几乎成为了“政治正确”的代言，许多发行版也将默认混成器换为 Wayland（例如 Fedora）。但是我一直都是坚定的 X11 人。</p><ul><li>最让我无法接受的是 Wayland 协议下无法获取当前窗口标题，这直接导致了 <a href="https://github.com/ActivityWatch/activitywatch/issues/92" target="_blank" rel="noopener noreferrer">activitywatch 无法使用</a>，而这是我的刚需。</li><li>某些软件的 Wayland 协议适配差，例如 <em>腾讯会议</em>（摄像头无法使用）。 <ul><li>远程桌面基本上用不了。(<a href="https://luoxu.archlinuxcn.org/#g=1031857103&amp;q=wayland+%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2" target="_blank" rel="noopener noreferrer">ref</a>)</li></ul></li></ul><h2 id="服务" tabindex="-1"><a class="header-anchor" href="#服务"><span>服务</span></a></h2><p>与 windows <em>service</em> 的概念相通。</p><ul><li>service 是由 <a href="https://wiki.archlinux.org/title/systemd" target="_blank" rel="noopener noreferrer">systemd</a> 支持的，而现在几乎所有的发行版都基于 systemd，因此什么老发行版的 <code>service</code> 指令就不用看了，用 <code>systemctl</code> 就行了。</li><li>查看服务的输出（stdout/stderr），一般在 status 里会有几条，也可以前往<a href="#%E6%97%A5%E5%BF%97">日志</a>查看。</li></ul>',54)),s("details",g,[e[11]||(e[11]=s("summary",null,"老版 service 命令内容",-1)),e[12]||(e[12]=s("p",null,"虽然我这里说不用看，但是还是有一些傻逼发行版，比如 OpenWRT 会用。而且还带了很多坑。",-1)),s("ul",null,[s("li",null,[e[8]||(e[8]=i("服务定义在 ")),e[9]||(e[9]=s("code",null,"/etc/init.d/xxx",-1)),e[10]||(e[10]=i("，每个服务都是一个 bash 脚本。 ")),s("ul",null,[s("li",null,[e[6]||(e[6]=i("bash 脚本里面可能会用一些发行版限定的函数。OpenWRT 的服务请跳转 ")),t(l,{to:"/articles/linux/openwrt.html#%E6%9C%8D%E5%8A%A1"},{default:p(()=>e[5]||(e[5]=[i("OpenWRT")])),_:1}),e[7]||(e[7]=i("。"))])])])])]),e[17]||(e[17]=a(`<h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><p>每个服务（unit）是一个 <code>.service</code> 文件，存放在不同位置：</p><ul><li><p><code>/usr/lib/systemd/system/</code>：由软件安装的服务</p></li><li><p><code>/etc/systemd/system</code>：系统用户写的服务（优先级最高）</p></li><li><p><code>~/.config/systemd/user</code>：普通用户写的服务，需要 <code>--user</code></p></li><li><p><code>xxx@.service</code> 是一个 template unit，不能直接启动，而是需要传入一个 string，作为 <code>xxx@something.service</code> 启动。string 的含义需要自己看 service 内容。</p></li></ul><h3 id="常用指令-1" tabindex="-1"><a class="header-anchor" href="#常用指令-1"><span>常用指令</span></a></h3><p><code>systemctl &lt;operation&gt; &lt;service_name&gt;</code>，无需打 <code>.service</code> 全名。</p><ul><li><code>systemctl</code> 默认操作的是全局作用域（系统服务），加上 <code>--user</code> 是用户作用域。用户作用域服务不需要 root 权限。</li><li><code>status</code> 是查看服务运行状态，用得最多的。</li><li><code>start</code> &amp; <code>stop</code>，启动和暂停，不多说</li><li><code>enable</code> &amp; <code>disable</code>，设置是否开机自启 <ul><li><code>enable --now</code> == <code>enable</code> + <code>start</code></li></ul></li><li><code>mask</code> （深度）禁用。</li><li><code>edit</code> 是编辑服务，可以查看服务的代码。</li></ul><h3 id="wsl2" tabindex="-1"><a class="header-anchor" href="#wsl2"><span>WSL2</span></a></h3><p>WSL2(ArchWSL) 由于不从 systemd 启动，导致无法使用 <code>systemctl</code> 管理服务。</p><p>解法是有一个 python 实现的 <a href="https://github.com/gdraheim/docker-systemctl-replacement" target="_blank" rel="noopener noreferrer">docker-systemctl-replacement</a>，可以代替(?) <code>systemctl</code> 的功能。(<a href="https://github.com/yuk7/ArchWSL/issues/20" target="_blank" rel="noopener noreferrer">ref</a>)</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> curl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl3.py</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /usr/bin/systemctl</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> python</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /usr/bin/systemctl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">comman</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="日志" tabindex="-1"><a class="header-anchor" href="#日志"><span>日志</span></a></h2><ul><li><code>journalctl</code> 用于查看系统日志。 <ul><li><code>journalctl -u &lt;service_name&gt;</code> 查看服务日志</li><li>我个人喜欢用 <code>journalctl -exu &lt;service_name&gt;</code>，<code>-e</code> 是直接跳转到末尾（最新日志），<code>-x</code> 是显示更加详细的帮助信息，对 warning 和 error 比较友好。</li></ul></li><li><code>dmesg</code> 用于查看内核消息。</li></ul><h2 id="desktop" tabindex="-1"><a class="header-anchor" href="#desktop"><span>.desktop</span></a></h2><p>许多软件安装后可以在 krunner 中直接运行，实际上就是读取了 <em>.desktop file</em>。</p><p>软件的 <em>.desktop file</em> 一般保存在 <code>~/.local/share/applications</code>。</p><p><em>.desktop file</em> 理解为启动脚本。只要随便打开看一个就懂了。</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Desktop</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Entry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=e</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">vince</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Comment</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=e</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">vince pdf reader</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=A</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">pplication</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Exec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=e</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">vince -o</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Terminal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里提供一个较小的 <code>.desktop</code> file 示例，若软件不自带，可以考虑自己写个。</p><h2 id="文件传输" tabindex="-1"><a class="header-anchor" href="#文件传输"><span>文件传输</span></a></h2><p>rsync 用于主机之间的文件传输，带有断点恢复等功能，吊打 scp 等。</p><p>我比较推荐 <code>rsync -aviuzP ...</code>。具体什么意思，这里不赘述（RTFM）。</p><h2 id="external" tabindex="-1"><a class="header-anchor" href="#external"><span>external</span></a></h2><ol><li>了解一下 btrfs（注意时效）：<a href="https://www.mivm.cn/linux-btrfs-usage-guide" target="_blank" rel="noopener noreferrer">Linux Btrfs 文件系统使用指南</a></li><li><a href="https://catcat.cc/post/2020-10-31/" target="_blank" rel="noopener noreferrer">Linux fontconfig 的字体匹配机制</a></li><li><a href="https://blog.lilydjwg.me/2023/7/25/btrfs-metadata-full.216670.html" target="_blank" rel="noopener noreferrer">btrfs 元数据满了怎么办</a></li><li>A chapter of <a href="https://github.com/asukaminato0721/PKGBUILD-cookbook/blob/master/launch.md" target="_blank" rel="noopener noreferrer">PKGBUILD-cookbook</a></li><li><a href="https://www.eaimty.com/2020/zfs-file-system/" target="_blank" rel="noopener noreferrer">ZFS ── 瑞士军刀般的文件系统</a></li><li><a href="https://www.ducksoft.site/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/fuck-hdf5-compression-using-btrfs.html" target="_blank" rel="noopener noreferrer">使用 btrfs 提升 HDF5 透明压缩百倍性能</a></li><li>深入原理：<a href="https://farseerfc.me/zhs/btrfs-vs-zfs-difference-in-implementing-snapshots.html" target="_blank" rel="noopener noreferrer">Btrfs vs ZFS 实现 snapshot 的差异</a></li></ol>`,23))])}const b=o(k,[["render",m],["__file","basic.html.vue"]]),y=JSON.parse('{"path":"/articles/linux/basic.html","title":"基础","lang":"zh-CN","frontmatter":{"date":"2023-10-28T00:00:00.000Z","icon":"microchip","category":["教程"],"tag":["Linux","桌面端"],"description":"基础 我建议仔细看看 The Missing的前几章，比较到位，免去了自己折腾之苦（本人亲身体会）。 Linux ls -al 得到的结果代表什么意思？ [Y/n] 可以直接回车表示确认。Y 大写表示默认。(ref) awk 是一门（图灵完备的）语言(ref)，。 linux 可执行文件没有后缀；可以用 detect-it-easy-bin Termi...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-14T17:34:14.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://absx.pages.dev/articles/linux/basic.html"}],["meta",{"property":"og:site_name","content":"绝对值_x 的博客"}],["meta",{"property":"og:title","content":"基础"}],["meta",{"property":"og:description","content":"基础 我建议仔细看看 The Missing的前几章，比较到位，免去了自己折腾之苦（本人亲身体会）。 Linux ls -al 得到的结果代表什么意思？ [Y/n] 可以直接回车表示确认。Y 大写表示默认。(ref) awk 是一门（图灵完备的）语言(ref)，。 linux 可执行文件没有后缀；可以用 detect-it-easy-bin Termi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-14T17:34:14.000Z"}],["meta",{"property":"article:tag","content":"桌面端"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:published_time","content":"2023-10-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-14T17:34:14.000Z"}]]},"git":{"createdTime":1698495742000,"updatedTime":1734197654000,"contributors":[{"name":"lxl66566","username":"lxl66566","email":"18259734087@163.com","commits":29,"url":"https://github.com/lxl66566"}]},"readingTime":{"minutes":8.33,"words":2500},"filePathRelative":"articles/linux/basic.md","localizedDate":"2023年10月28日","excerpt":"\\n","autoDesc":true}');export{b as comp,y as data};
